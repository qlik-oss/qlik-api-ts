import {
  getInterceptors
} from "./7BDAXGID.js";
import {
  isBrowser,
  isNode
} from "./2ZQ3ZX7F.js";

// src/platform/platform-functions.ts
var getPlatform = async (options = {}) => {
  const isNodeEnvironment = typeof window === "undefined";
  if (isNodeEnvironment) {
    return result({ isNodeEnv: true });
  }
  const { data: productInfo, status } = await getProductInfo(options);
  if (status === 404) {
    return result({ isUnknown: true });
  }
  if (!productInfo || status <= 399 && status >= 300) {
    return result({ isQSE: true, isWindows: true });
  }
  const deploymentType = (productInfo.composition?.deploymentType || "").toLowerCase();
  const isControlCenter = deploymentType === "controlcenter";
  if (deploymentType === "qliksenseserver") {
    return result({ isQSE: true, isWindows: true });
  }
  if (deploymentType === "qliksensedesktop") {
    return result({ isQSD: true, isWindows: true });
  }
  if (productInfo.composition?.provider === "fedramp") {
    return result({ isCloud: true, isQCG: true, isControlCenter });
  }
  return result({ isCloud: true, isQCS: true, isControlCenter });
};
var productInfoPromises = {};
function templateUrl(baseUrl) {
  return `${baseUrl}/resources/autogenerated/product-info.json`;
}
var getProductInfo = async ({ hostConfig, noCache } = {}) => {
  const url = toValidLocationUrl(hostConfig);
  const completeUrl = templateUrl(url);
  try {
    if (!(completeUrl in productInfoPromises)) {
      const fetchOptions = {};
      if (globalThis.QlikMain && globalThis.QlikMain.resourceNeedsCredentials(completeUrl)) {
        fetchOptions.credentials = "include";
      }
      const productInfoPromise = fetch(completeUrl, fetchOptions).then(async (res) => {
        if (res.ok) {
          return { data: await res.json(), status: res.status };
        }
        return { data: void 0, status: res.status };
      });
      productInfoPromises[completeUrl] = productInfoPromise;
    }
    const response = await productInfoPromises[completeUrl];
    if (response.status >= 400 || !response.data) {
      delete productInfoPromises[completeUrl];
    }
    return response;
  } catch (err) {
    delete productInfoPromises[completeUrl];
    return { data: void 0, status: 500 };
  } finally {
    if (noCache) {
      delete productInfoPromises[completeUrl];
    }
  }
};
var result = (data) => ({
  isNodeEnv: false,
  isCloud: false,
  isQCS: false,
  isQCG: false,
  isControlCenter: false,
  isWindows: false,
  isQSE: false,
  isQSD: false,
  isUnknown: false,
  ...data
});

// src/auth/internal/default-host-config.ts
var defaultHostConfig = {};
function setDefaultHostConfig(hostConfig) {
  defaultHostConfig = hostConfig || {};
}
function withDefaultHostConfig(hostConfig) {
  if (hostConfig && Object.keys(hostConfig).length > 0) {
    return hostConfig;
  }
  return defaultHostConfig;
}

// src/auth/internal/auth-module-registry.ts
var authModules = {};
var ongoingAuthModuleLoading = Promise.resolve();
function registerAuthModule(name, authModule) {
  authModules[name.toLowerCase()] = authModule;
}
function getRegisteredAuthModules() {
  return Object.keys(authModules);
}
function getRegisteredAuthModule(authType) {
  return authModules[authType.toLowerCase()];
}
async function getAuthModule(hostConfig) {
  const hostConfigToUse = withDefaultHostConfig(hostConfig);
  const authType = await guessAuthTypeIfMissing(hostConfigToUse);
  if (ongoingAuthModuleLoading) {
    await ongoingAuthModuleLoading;
  }
  let authModule = getRegisteredAuthModule(authType);
  if (!authModule) {
    ongoingAuthModuleLoading = (async () => {
      authModule = await resolveGloballyDefinedAuthModule(authType);
      if (authModule) {
        registerAuthModule(authType, authModule);
      }
    })();
    await ongoingAuthModuleLoading;
  }
  if (!authModule) {
    throw new InvalidAuthTypeError(authType);
  }
  if (authModule.validateHostConfig) {
    authModule.validateHostConfig({ authType, ...hostConfigToUse });
  }
  return authModule;
}
async function guessAuthTypeIfMissing(hostConfig) {
  if (hostConfig.authType) {
    return hostConfig.authType;
  }
  if (hostConfig.apiKey) {
    return "apikey";
  }
  if (hostConfig.accessCode) {
    return "anonymous";
  }
  if (hostConfig.clientId) {
    return "oauth2";
  }
  if (hostConfig.webIntegrationId) {
    return "cookie";
  }
  if (await isWindows(hostConfig)) {
    return "windowscookie";
  }
  return "cookie";
}
async function resolveGloballyDefinedAuthModule(authType) {
  const globalWindow = globalThis;
  const globalVariable = globalWindow[authType];
  if (globalVariable) {
    let potentialAuthModule;
    if (typeof globalVariable === "function") {
      potentialAuthModule = await globalVariable();
    } else {
      potentialAuthModule = globalVariable;
    }
    if (potentialAuthModule && potentialAuthModule.getRestCallAuthParams && potentialAuthModule.getWebSocketAuthParams && potentialAuthModule.handleAuthenticationError) {
      return potentialAuthModule;
    }
    console.error("Not a valid auth module", potentialAuthModule);
    throw new InvalidAuthTypeError(authType);
  }
  return Promise.resolve(void 0);
}

// src/auth/auth-errors.ts
var InvalidHostConfigError = class extends Error {
  constructor(message) {
    super(`Invalid host config: ${message}`);
    this.name = "InvalidHostConfigError";
  }
};
var UnexpectedAuthTypeError = class extends Error {
  constructor(...expectedAuthTypes) {
    const ors = expectedAuthTypes.map((item, index) => index === 0 ? `"${item}"` : `or "${item}"`).join(" ");
    super(`HostConfig is not properly configured. authType is expected to be ${ors}`);
    this.name = "UnexpectedAuthTypeError";
  }
};
var InvalidAuthTypeError = class extends Error {
  constructor(authType) {
    const validAuthModules = getRegisteredAuthModules();
    super(
      `Not a valid auth type: ${authType}, valid auth types are; '${validAuthModules.filter((name) => name !== "QmfeEmbedFramerAuthModule").join("', '")}'`
    );
    this.name = "InvalidAuthTypeError";
  }
};
function errorToString({ title, detail, code, status }) {
  if (detail) {
    return `${title} - ${detail} (Status: ${status}, Code: ${code})`;
  }
  return `${title} (Status: ${status}, Code: ${code})`;
}
var AuthorizationError = class extends Error {
  errors;
  constructor(errors) {
    if (typeof errors !== "object") {
      super("Unknown error");
      return;
    }
    const errorArray = Array.isArray(errors) ? errors : [errors];
    super(errorArray.map(errorToString).join(", "));
    this.errors = errorArray;
  }
};

// src/auth/auth-functions.ts
var lastErrorMessage = "";
function logToConsole({ message }) {
  if (message !== lastErrorMessage) {
    lastErrorMessage = message;
    console.error(message);
  }
}
function isHostCrossOrigin(hostConfig) {
  if (!globalThis.location?.origin) {
    return true;
  }
  const hostConfigToUse = withDefaultHostConfig(hostConfig);
  if (Object.keys(hostConfigToUse).length === 0) {
    return false;
  }
  try {
    const locationUrl = new URL(toValidLocationUrl(hostConfigToUse));
    return locationUrl.origin !== globalThis.location.origin;
  } catch {
  }
  return false;
}
async function isWindows(hostConfig) {
  const hostConfigToUse = withDefaultHostConfig(hostConfig);
  if (hostConfigToUse.authType === "cookie") {
    return false;
  }
  if (hostConfigToUse.authType === "windowscookie") {
    return true;
  }
  return (await getPlatform({ hostConfig })).isWindows;
}
function toValidLocationUrl(hostConfig) {
  const url = withDefaultHostConfig(hostConfig)?.host;
  let locationUrl;
  if (!url) {
    locationUrl = "";
  } else if (url.toLowerCase().startsWith("https://") || url.toLowerCase().startsWith("http://")) {
    locationUrl = url;
  } else {
    locationUrl = `https://${url}`;
  }
  while (locationUrl[locationUrl.length - 1] === "/") {
    locationUrl = locationUrl.substring(0, locationUrl.length - 1);
  }
  return locationUrl;
}
function toValidEnigmaLocationUrl(hostConfig) {
  return toValidWebsocketLocationUrl(hostConfig);
}
function toValidWebsocketLocationUrl(hostConfig) {
  const url = withDefaultHostConfig(hostConfig)?.host;
  let locationUrl;
  if (!url) {
    locationUrl = globalThis.location.origin;
  } else if (url.toLowerCase().startsWith("https://") || url.toLowerCase().startsWith("http://")) {
    locationUrl = url;
  } else {
    locationUrl = `https://${url}`;
  }
  while (locationUrl[locationUrl.length - 1] === "/") {
    locationUrl = locationUrl.substring(0, locationUrl.length - 1);
  }
  return locationUrl.replace(leadingHttp, "ws");
}
async function getWebSocketAuthParams(props) {
  const hostConfigToUse = withDefaultHostConfig(props.hostConfig);
  try {
    const authModule = await getAuthModule(hostConfigToUse);
    return await authModule.getWebSocketAuthParams({
      ...props,
      hostConfig: hostConfigToUse
    });
  } catch (err) {
    (hostConfigToUse.onAuthFailed || logToConsole)(normalizeAuthModuleError(err));
    throw err;
  }
}
async function getWebResourceAuthParams(props) {
  const hostConfigToUse = withDefaultHostConfig(props.hostConfig);
  try {
    const authModule = await getAuthModule(hostConfigToUse);
    return await authModule.getWebResourceAuthParams?.({
      ...props,
      hostConfig: hostConfigToUse
    }) || { queryParams: {} };
  } catch (err) {
    (hostConfigToUse.onAuthFailed || logToConsole)(normalizeAuthModuleError(err));
    throw err;
  }
}
async function handleAuthenticationError(props) {
  const hostConfigToUse = withDefaultHostConfig(props.hostConfig);
  const authModule = await getAuthModule(hostConfigToUse);
  const result2 = await authModule.handleAuthenticationError({
    ...props,
    hostConfig: hostConfigToUse
  });
  const willRetry = props.canRetry && result2.retry;
  const willHangUntilANewPageIsLoaded = result2.preventDefault;
  if (!willRetry && !willHangUntilANewPageIsLoaded) {
    const { status, errorBody } = props;
    (hostConfigToUse.onAuthFailed || logToConsole)(normalizeInbandAuthError({ status, errorBody }));
  }
  return result2;
}
async function getRestCallAuthParams(props) {
  const hostConfigToUse = withDefaultHostConfig(props.hostConfig);
  try {
    const authModule = await getAuthModule(hostConfigToUse);
    return await authModule.getRestCallAuthParams({
      ...props,
      hostConfig: hostConfigToUse
    });
  } catch (err) {
    (hostConfigToUse.onAuthFailed || logToConsole)(normalizeAuthModuleError(err));
    throw err;
  }
}
async function getAccessToken(props) {
  const res = await getRestCallAuthParams({ method: "GET", ...props });
  const authorizationHeader = res.headers?.Authorization;
  if (authorizationHeader.indexOf("Bearer ") === 0) {
    return authorizationHeader.substring(7);
  }
  throw new Error("Unknown format of authorization header returned by remote auth module");
}
function registerAuthModule2(name, authModule) {
  registerAuthModule(name, authModule);
}
function setDefaultHostConfig2(hostConfig) {
  setDefaultHostConfig(hostConfig);
}
function serializeHostConfig(hostConfig) {
  const hostConfigToUse = withDefaultHostConfig(hostConfig);
  return JSON.stringify(hostConfigToUse, hostConfigPropertyIgnorer);
}
function checkForCrossDomainRequest(hostConfig) {
  const hostConfigToUse = withDefaultHostConfig(hostConfig);
  if (isHostCrossOrigin(hostConfigToUse)) {
    if (Object.keys(hostConfigToUse).length === 0) {
      throw new InvalidHostConfigError("a host config must be provided when making a cross domain request");
    }
    if (!hostConfigToUse.host) {
      throw new InvalidHostConfigError("A 'host' must be set in host config when making a cross domain request");
    }
  }
}
var logout = () => {
  globalThis.loggingOut = true;
  globalThis.location.href = "/logout";
};
var leadingHttp = /^http/;
function normalizeInbandAuthError({ errorBody, status }) {
  const authError = errorBody;
  if (typeof authError?.errors === "object") {
    const err = new AuthorizationError(authError?.errors);
    return { message: err.message };
  }
  return { message: `HTTP ${status}` };
}
function normalizeAuthModuleError(err) {
  return { message: err.message || "Unknown error" };
}
function hostConfigPropertyIgnorer(key, value) {
  if (key === "") {
    return value;
  }
  if (key === "authType") {
    return void 0;
  }
  const vtype = typeof value;
  if (vtype === "object" || vtype === "function") {
    return void 0;
  }
  return value;
}

// src/random/random.ts
import { customAlphabet, nanoid } from "nanoid";
function generateRandomString(targetLength) {
  return nanoid(targetLength);
}
function generateRandomHexString(targetLength) {
  return customAlphabet("1234567890abcdef", targetLength)();
}

// src/auth/internal/auth-functions.ts
function getCredentialsForCookieAuth(hostConfig) {
  if (hostConfig.crossSiteCookies === false) {
    return "same-origin";
  }
  if (isHostCrossOrigin(hostConfig)) {
    return "include";
  }
  return "same-origin";
}
function internalValidateHostConfig(hostConfig, options) {
  const missingRequiredProps = [];
  for (const requiredProp of options.requiredProps) {
    if (!hostConfig[requiredProp]) {
      missingRequiredProps.push(requiredProp);
    }
  }
  if (missingRequiredProps.length > 0) {
    throw new InvalidHostConfigError(
      `missing required properties in host config; '${missingRequiredProps.join("', '")}'`
    );
  }
  const validProps = [
    "authType",
    "autoRedirect",
    "authRedirectUserConfirmation",
    "embedRuntimeUrl",
    "host",
    "onAuthFailed",
    ...options.requiredProps,
    ...options.optionalProps
  ];
  const invalidKeys = [];
  Object.keys(hostConfig).forEach((key) => {
    if (!validProps.some((k) => k === key)) {
      invalidKeys.push(key);
    }
  });
  if (invalidKeys.length > 0) {
    throw new InvalidHostConfigError(`unknown properties in host config; '${invalidKeys.join("', '")}'`);
  }
  return true;
}

// src/auth/internal/default-auth-modules/oauth/storage-helpers.ts
var storagePrefix = "qlik-qmfe-api";
function getTopicFromOauthHostConfig(hostConfig) {
  let topic = `${hostConfig.clientId + (hostConfig.scope ? `_${hostConfig.scope}` : "_user_default")}`;
  if (hostConfig.subject) {
    topic += `_${hostConfig.subject}`;
  }
  if (hostConfig.userId) {
    topic += `_${hostConfig.userId}`;
  }
  return topic;
}
function getTopicFromAnonHostConfig(hostConfig) {
  return `${hostConfig.accessCode}_${hostConfig.clientId}`;
}
var cachedTokens = {};
function saveInLocalStorage(topic, name, value) {
  localStorage.setItem(`${storagePrefix}-${topic}-${name}`, value);
}
function saveInSessionStorage(topic, name, value) {
  sessionStorage.setItem(`${storagePrefix}-${topic}-${name}`, value);
}
function loadFromLocalStorage(topic, name) {
  return localStorage.getItem(`${storagePrefix}-${topic}-${name}`) || void 0;
}
function loadFromSessionStorage(topic, name) {
  return sessionStorage.getItem(`${storagePrefix}-${topic}-${name}`) || void 0;
}
function deleteFromLocalStorage(topic, names) {
  names.forEach((name) => localStorage.removeItem(`${storagePrefix}-${topic}-${name}`));
}
function deleteFromSessionStorage(topic, names) {
  names.forEach((name) => sessionStorage.removeItem(`${storagePrefix}-${topic}-${name}`));
}
function loadAndDeleteFromSessionStorage(topic, name) {
  const id = `${storagePrefix}-${topic}-${name}`;
  const result2 = sessionStorage.getItem(id) || void 0;
  sessionStorage.removeItem(id);
  return result2;
}
function loadOauthTokensFromStorage(topic, accessTokenStorage) {
  let accessToken;
  let refreshToken;
  if (accessTokenStorage === "local") {
    accessToken = loadFromLocalStorage(topic, "access-token");
    refreshToken = loadFromLocalStorage(topic, "refresh-token");
  } else if (accessTokenStorage === "session") {
    accessToken = loadFromSessionStorage(topic, "access-token");
    refreshToken = loadFromSessionStorage(topic, "refresh-token");
  }
  if (accessToken) {
    return {
      accessToken,
      refreshToken
    };
  }
  return void 0;
}
async function loadCachedOauthTokens(hostConfig) {
  return cachedTokens[getTopicFromOauthHostConfig(hostConfig)];
}
async function loadOrAcquireAccessTokenOauth(hostConfig, acquireTokens) {
  if (!hostConfig.clientId) {
    throw new InvalidHostConfigError('A host config with authType set to "oauth2" has to also provide a clientId');
  }
  const topic = getTopicFromOauthHostConfig(hostConfig);
  return loadOrAcquireAccessToken(topic, acquireTokens, hostConfig.noCache, hostConfig.accessTokenStorage);
}
async function loadOrAcquireAccessTokenAnon(hostConfig, acquireTokens) {
  if (!hostConfig.accessCode) {
    throw new InvalidHostConfigError(
      'A host config with authType set to "anonymous" has to also provide an accessCode'
    );
  }
  const topic = getTopicFromAnonHostConfig(hostConfig);
  return loadOrAcquireAccessToken(topic, acquireTokens, false, void 0);
}
async function loadOrAcquireAccessToken(topic, acquireTokens, noCache, accessTokenStorage) {
  if (noCache) {
    return acquireTokens();
  }
  const mayUseStorage = isBrowser();
  const storedOauthTokens = cachedTokens[topic] || (mayUseStorage ? loadOauthTokensFromStorage(topic, accessTokenStorage) : void 0);
  if (storedOauthTokens) {
    return Promise.resolve(storedOauthTokens);
  }
  const tokensPromise = acquireTokens();
  cachedTokens[topic] = tokensPromise;
  if (mayUseStorage) {
    const tokens = await tokensPromise;
    if (accessTokenStorage === "local" && tokens) {
      if (tokens.accessToken) {
        saveInLocalStorage(topic, "access-token", tokens.accessToken);
      }
      if (tokens.refreshToken) {
        saveInLocalStorage(topic, "refresh-token", tokens.refreshToken);
      }
    } else if (accessTokenStorage === "session" && tokens) {
      if (tokens.accessToken) {
        saveInSessionStorage(topic, "access-token", tokens.accessToken);
      }
      if (tokens.refreshToken) {
        saveInSessionStorage(topic, "refresh-token", tokens.refreshToken);
      }
    }
  }
  return tokensPromise;
}
function clearStoredOauthTokens(hostConfig) {
  const topic = getTopicFromOauthHostConfig(hostConfig);
  delete cachedTokens[topic];
  if (isBrowser()) {
    deleteFromLocalStorage(topic, ["access-token", "refresh-token"]);
    deleteFromSessionStorage(topic, ["access-token", "refresh-token"]);
  }
}
function clearStoredAnonymousTokens(hostConfig) {
  const topic = getTopicFromAnonHostConfig(hostConfig);
  delete cachedTokens[topic];
  if (isBrowser()) {
    deleteFromLocalStorage(topic, ["access-token", "refresh-token"]);
    deleteFromSessionStorage(topic, ["access-token", "refresh-token"]);
  }
}

// src/auth/internal/default-auth-modules/oauth/oauth-utils.ts
function toPerformInteractiveLoginFunction(performInteractiveLogin) {
  if (typeof performInteractiveLogin === "string") {
    const fn = lookupInteractiveLoginFn(performInteractiveLogin);
    if (!fn) {
      throw new Error(`No such function: ${performInteractiveLogin}`);
    }
    return fn;
  }
  return performInteractiveLogin;
}
function lookupGetAccessFn(getAccessToken2) {
  return globalThis[getAccessToken2];
}
function lookupInteractiveLoginFn(name) {
  return globalThis[name];
}
function handlePossibleErrors(data) {
  if (data.errors) {
    throw new AuthorizationError(data.errors);
  }
}
function toQueryString(queryParams) {
  const queryParamsKeys = Object.keys(queryParams);
  queryParamsKeys.sort();
  const query = queryParamsKeys.map((k) => `${k}=${queryParams[k]}`).join("&");
  return query;
}
function byteArrayToBase64(hashArray) {
  let result2 = "";
  if (isBrowser()) {
    const byteArrayToString = String.fromCharCode.apply(null, hashArray);
    result2 = btoa(byteArrayToString);
  } else if (isNode()) {
    result2 = Buffer.from(hashArray).toString("base64");
  } else {
    throw new Error("Environment not supported for oauth2 authentication");
  }
  return result2;
}
async function sha256(message) {
  const msgBuffer = new TextEncoder().encode(message);
  const hashBuffer = await globalThis.crypto.subtle.digest("SHA-256", msgBuffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashBase64 = byteArrayToBase64(hashArray);
  return hashBase64.replaceAll(/\+/g, "-").replaceAll(/\//g, "_").replace(/=+$/, "");
}
async function createInteractiveLoginUrl(hostConfig, redirectUri, state, verifier) {
  const clientId = hostConfig.clientId || "";
  const locationUrl = toValidLocationUrl(hostConfig);
  const codeChallenge = await sha256(verifier);
  const queryParams = {
    response_type: "code",
    client_id: clientId,
    redirect_uri: redirectUri,
    scope: hostConfig.scope || "user_default",
    state,
    code_challenge: codeChallenge,
    code_challenge_method: "S256"
  };
  return `${locationUrl}/oauth/authorize?${toQueryString(queryParams)}`;
}
async function startFullPageLoginFlow(hostConfig) {
  const clientId = hostConfig.clientId || "";
  const locationUrl = toValidLocationUrl(hostConfig);
  const verifier = generateRandomString(128);
  const state = generateRandomString(43);
  const codeChallenge = await sha256(verifier);
  const redirectUri = hostConfig.redirectUri || globalThis.location.href;
  const topic = getTopicFromOauthHostConfig(hostConfig);
  clearStoredOauthTokens(hostConfig);
  saveInSessionStorage(topic, "state", state);
  saveInSessionStorage(topic, "verifier", verifier);
  saveInSessionStorage(topic, "href", globalThis.location.href);
  saveInSessionStorage("", "client-in-progress", topic);
  const queryParams = {
    response_type: "code",
    client_id: clientId,
    redirect_uri: redirectUri,
    scope: hostConfig.scope || "user_default",
    state,
    code_challenge: codeChallenge,
    code_challenge_method: "S256"
  };
  const url = `${locationUrl}/oauth/authorize?${toQueryString(queryParams)}`;
  globalThis.location.replace(url);
}
async function exchangeCodeAndVerifierForAccessTokenData(hostConfig, code, verifier, redirectUri) {
  try {
    const result2 = await fetch(`${toValidLocationUrl(hostConfig)}/oauth/token`, {
      method: "POST",
      credentials: "include",
      mode: "cors",
      headers: { "content-type": "application/json" },
      redirect: "follow",
      body: JSON.stringify({
        grant_type: "authorization_code",
        scope: hostConfig.scope || "user_default",
        ...code ? { code } : {},
        ...{ redirect_uri: redirectUri || globalThis.location.href },
        ...verifier ? { code_verifier: verifier } : {},
        client_id: hostConfig.clientId
      })
    });
    const data = await result2.json();
    handlePossibleErrors(data);
    return {
      accessToken: data.access_token,
      refreshToken: data.refresh_token,
      errors: data.errors
    };
  } catch (err) {
    console.error(err);
    return new Promise(() => {
    });
  }
}
function createBodyWithCredentialsEtc(clientId, clientSecret, scope, subject, userId) {
  const commonProps = {
    client_id: clientId,
    client_secret: clientSecret,
    scope
  };
  if (subject) {
    return {
      ...commonProps,
      grant_type: "urn:qlik:oauth:user-impersonation",
      user_lookup: {
        field: "subject",
        value: subject
      }
    };
  }
  if (userId) {
    return {
      ...commonProps,
      grant_type: "urn:qlik:oauth:user-impersonation",
      user_lookup: {
        field: "userId",
        value: userId
      }
    };
  }
  return {
    ...commonProps,
    grant_type: "client_credentials"
  };
}
async function getOauthTokensWithCredentials(baseUrl, clientId, clientSecret, scope = "user_default", subject, userId) {
  const result2 = await fetch(`${baseUrl}/oauth/token`, {
    method: "POST",
    mode: "cors",
    headers: { "content-type": "application/json" },
    body: JSON.stringify(createBodyWithCredentialsEtc(clientId, clientSecret, scope, subject, userId))
  });
  const data = await result2.json();
  return {
    accessToken: data.access_token,
    refreshToken: data.refresh_token,
    errors: data.errors
  };
}
async function getOauthTokensWithRefreshToken(baseUrl, refreshToken, clientSecret) {
  const result2 = await fetch(`${baseUrl}/oauth/token`, {
    method: "POST",
    mode: "cors",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({
      grant_type: "refresh_token",
      refresh_token: refreshToken,
      client_secret: clientSecret
    })
  });
  const data = await result2.json();
  return {
    accessToken: data.access_token,
    refreshToken: data.refresh_token,
    errors: data.errors
  };
}
async function getAnonymousOauthAccessToken(baseUrl, accessCode, clientId, trackingCode) {
  const result2 = await fetch(`${baseUrl}/oauth/token/anonymous-embed`, {
    method: "POST",
    mode: "cors",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({
      eac: accessCode,
      client_id: clientId,
      grant_type: "urn:qlik:oauth:anonymous-embed",
      tracking_code: trackingCode
    })
  });
  const data = await result2.json();
  return {
    accessToken: data.access_token,
    refreshToken: data.refresh_token,
    errors: data.errors
  };
}
async function getOAuthTokensForNode(hostConfig) {
  const { clientId, clientSecret } = hostConfig;
  if (!clientId || !clientSecret) {
    throw new InvalidHostConfigError(
      'A host config with authType set to "oauth2" has to provide a clientId and a clientSecret'
    );
  }
  const oauthTokens = await loadOrAcquireAccessTokenOauth(hostConfig, async () => {
    if (!hostConfig.clientId || !hostConfig.clientSecret) {
      throw new InvalidHostConfigError(
        'A host config with authType set to "oauth2" has to provide a clientId and a clientSecret'
      );
    }
    return getOauthTokensWithCredentials(
      toValidLocationUrl(hostConfig),
      hostConfig.clientId,
      hostConfig.clientSecret,
      hostConfig.scope,
      hostConfig.subject,
      hostConfig.userId
    );
  });
  return oauthTokens;
}
async function getOAuthTokensForBrowser(hostConfig) {
  const { clientId } = hostConfig;
  if (!clientId) {
    throw new InvalidHostConfigError('A host config with authType set to "oauth2" has to also provide a clientId');
  }
  const oauthTokens = await loadOrAcquireAccessTokenOauth(hostConfig, async () => {
    if (hostConfig.getAccessToken) {
      try {
        const tokenFetchedFromRemote = typeof hostConfig.getAccessToken === "string" ? await lookupGetAccessFn(hostConfig.getAccessToken)() : await hostConfig.getAccessToken();
        return {
          accessToken: tokenFetchedFromRemote,
          refreshToken: void 0,
          errors: void 0
        };
      } catch (error) {
        return errorMessageToAuthData("Could not fetch access token using custom function");
      }
    }
    if (hostConfig.performInteractiveLogin) {
      let usedRedirectUri;
      try {
        const verifier2 = generateRandomString(128);
        const originalState = generateRandomString(43);
        const { code: code2, state } = extractCodeAndState(
          await toPerformInteractiveLoginFunction(hostConfig.performInteractiveLogin)({
            getLoginUrl: async ({ redirectUri }) => {
              usedRedirectUri = redirectUri;
              return createInteractiveLoginUrl(hostConfig, redirectUri, originalState, verifier2);
            }
          })
        );
        if (!usedRedirectUri) {
          return errorMessageToAuthData("No redirect uri provided");
        }
        if (originalState !== state) {
          return errorMessageToAuthData("State returned by custom interactive login function does not match original");
        }
        if (!code2) {
          return errorMessageToAuthData("No code found in response from custom interactive login function");
        }
        const tokenResponse = await exchangeCodeAndVerifierForAccessTokenData(
          hostConfig,
          code2,
          verifier2,
          usedRedirectUri
        );
        return tokenResponse;
      } catch (error) {
        return {
          accessToken: void 0,
          refreshToken: void 0,
          errors: [
            {
              code: "",
              status: 401,
              title: "Could not perform custom interactive login",
              // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
              detail: `${error}`
            }
          ]
        };
      }
    }
    const topic = getTopicFromOauthHostConfig(hostConfig);
    const code = loadAndDeleteFromSessionStorage(topic, "code");
    const verifier = loadAndDeleteFromSessionStorage(topic, "verifier");
    if (code && verifier) {
      const tokenResponse = await exchangeCodeAndVerifierForAccessTokenData(
        hostConfig,
        code,
        verifier,
        hostConfig.redirectUri
      );
      if (tokenResponse) {
        return tokenResponse;
      }
    }
    return void 0;
  });
  if (oauthTokens) {
    return oauthTokens;
  }
  if (hostConfig.performInteractiveLogin) {
    return new Promise(() => {
    });
  }
  if (hostConfig.authRedirectUserConfirmation) {
    await hostConfig.authRedirectUserConfirmation();
  }
  startFullPageLoginFlow(hostConfig);
  return new Promise(() => {
  });
}
var lastOauthTokensCall = Promise.resolve("");
async function getOAuthAccessToken(hostConfig) {
  if (isNode()) {
    const tokens = await getOAuthTokensForNode(hostConfig);
    if (tokens) {
      handlePossibleErrors(tokens);
      return tokens.accessToken || "";
    }
    return "";
  }
  if (isBrowser()) {
    lastOauthTokensCall = lastOauthTokensCall.then(async () => {
      const tokens = await getOAuthTokensForBrowser(hostConfig);
      if (tokens) {
        handlePossibleErrors(tokens);
        return tokens.accessToken || "";
      }
      return "";
    });
  }
  return lastOauthTokensCall;
}
async function refreshAccessToken(hostConfig) {
  const tokens = await loadCachedOauthTokens(hostConfig);
  clearStoredOauthTokens(hostConfig);
  if (tokens && tokens.refreshToken && hostConfig.clientSecret) {
    const refreshedTokens = await loadOrAcquireAccessTokenOauth(hostConfig, async () => {
      if (!tokens || !tokens.refreshToken || !hostConfig.clientSecret) {
        throw new Error("Trying to refresh tokens without refreshToken or clientSecret");
      }
      return getOauthTokensWithRefreshToken(
        toValidLocationUrl(hostConfig),
        tokens.refreshToken,
        hostConfig.clientSecret
      );
    });
    if (refreshedTokens) {
      handlePossibleErrors(refreshedTokens);
    }
  }
}
function extractCodeAndState(input) {
  if (typeof input === "string") {
    const queryParams = new URLSearchParams(new URL(input).search);
    return {
      code: queryParams.get("code") || "",
      state: queryParams.get("state") || ""
    };
  }
  return input;
}
function errorMessageToAuthData(message) {
  return {
    accessToken: void 0,
    refreshToken: void 0,
    errors: [
      {
        code: "",
        status: 401,
        title: message,
        detail: ""
      }
    ]
  };
}

// src/auth/internal/default-auth-modules/oauth/temporary-token.ts
async function exchangeAccessTokenForTemporaryToken(hostConfig, accessToken, purpose) {
  const response = await fetch(`${toValidLocationUrl(hostConfig)}/oauth/token`, {
    method: "POST",
    credentials: "include",
    mode: "cors",
    headers: { "content-type": "application/json" },
    redirect: "follow",
    body: JSON.stringify({
      subject_token: accessToken,
      subject_token_type: "urn:ietf:params:oauth:token-type:access_token",
      grant_type: "urn:ietf:params:oauth:grant-type:token-exchange",
      purpose,
      redirect_uri: globalThis.location?.href,
      client_id: hostConfig.clientId
    })
  });
  if (response.status !== 200) {
    throw await toError(response);
  }
  const data = await response.json();
  return data.access_token;
}
async function toError(response) {
  const body = await response.text();
  try {
    const data = JSON.parse(body);
    return new AuthorizationError(data.errors);
  } catch (err) {
    return new AuthorizationError([
      {
        code: "unknown",
        status: response.status,
        detail: body,
        title: "Unknown authentication error"
      }
    ]);
  }
}

// src/auth/internal/default-auth-modules/anonymous.ts
async function handlePotentialAuthenticationErrorAndRetry(hostConfig, fn) {
  try {
    return await fn();
  } catch (err) {
    const { retry } = await handleAuthenticationError2({
      hostConfig,
      canRetry: true
    });
    if (retry) {
      return fn();
    }
    throw err;
  }
}
async function getOrCreateTrackingCode(hostConfig) {
  let trackingCode;
  if (isBrowser()) {
    const topic = getTopicFromAnonHostConfig(hostConfig);
    trackingCode = loadFromLocalStorage(topic, "tracking-code");
    if (!trackingCode) {
      trackingCode = createTrackingCode();
    }
    saveInLocalStorage(topic, "tracking-code", trackingCode);
  } else {
    trackingCode = createTrackingCode();
  }
  return trackingCode;
}
function createTrackingCode() {
  const timeStamp = Math.floor(Date.now() / 1e3).toString(16);
  const randomString = generateRandomHexString(40 - timeStamp.length);
  return `${timeStamp}${randomString}`;
}
async function getAnonymousAccessToken(hostConfig) {
  const { accessCode, clientId } = hostConfig;
  if (!accessCode || !clientId) {
    throw new InvalidHostConfigError(
      'A host config with authType set to "anonymous" has to provide both an accessCode and clientId'
    );
  }
  const tokens = await loadOrAcquireAccessTokenAnon(hostConfig, async () => {
    const baseUrl = toValidLocationUrl(hostConfig);
    const trackingCode = await getOrCreateTrackingCode(hostConfig);
    return getAnonymousOauthAccessToken(baseUrl, accessCode, clientId, trackingCode);
  });
  if (!tokens) {
    return "";
  }
  if (tokens.errors) {
    throw new AuthorizationError(tokens.errors);
  }
  if (tokens.accessToken) {
    return tokens.accessToken;
  }
  return "";
}
async function getRestCallAuthParams2({
  hostConfig
}) {
  return {
    headers: {
      Authorization: `Bearer ${await getAnonymousAccessToken(hostConfig)}`
    },
    queryParams: {},
    credentials: "omit"
  };
}
async function getWebSocketAuthParams2({
  hostConfig
}) {
  const websocketAccessToken = await handlePotentialAuthenticationErrorAndRetry(hostConfig, async () => {
    const accessToken = await getAnonymousAccessToken(hostConfig);
    return exchangeAccessTokenForTemporaryToken(hostConfig, accessToken, "websocket");
  });
  return {
    queryParams: {
      accessToken: websocketAccessToken
    }
  };
}
async function getWebResourceAuthParams2({
  hostConfig
}) {
  const websocketResourceAccessToken = await handlePotentialAuthenticationErrorAndRetry(hostConfig, async () => {
    const accessToken = await getAnonymousAccessToken(hostConfig);
    return exchangeAccessTokenForTemporaryToken(hostConfig, accessToken, "websocket");
  });
  return {
    queryParams: {
      accessToken: websocketResourceAccessToken
    }
  };
}
async function handleAuthenticationError2({
  hostConfig
}) {
  clearStoredAnonymousTokens(hostConfig);
  return {
    preventDefault: false,
    retry: true
  };
}
var anonymous_default = {
  getRestCallAuthParams: getRestCallAuthParams2,
  getWebSocketAuthParams: getWebSocketAuthParams2,
  getWebResourceAuthParams: getWebResourceAuthParams2,
  handleAuthenticationError: handleAuthenticationError2,
  validateHostConfig: (hostConfig) => internalValidateHostConfig(hostConfig, {
    requiredProps: ["clientId", "accessCode"],
    optionalProps: []
  })
};

// src/auth/internal/default-auth-modules/apikey.ts
function getRestCallAuthParams3({ hostConfig }) {
  return Promise.resolve({
    headers: {
      Authorization: `Bearer ${hostConfig?.apiKey}`
    },
    queryParams: {},
    credentials: "omit"
  });
}
async function getWebSocketAuthParams3() {
  return {
    queryParams: {
      // accessToken: hostConfig.apiKey,
    }
  };
}
function handleAuthenticationError3() {
  return Promise.resolve({});
}
var apikey_default = {
  getRestCallAuthParams: getRestCallAuthParams3,
  getWebSocketAuthParams: getWebSocketAuthParams3,
  handleAuthenticationError: handleAuthenticationError3,
  validateHostConfig: (hostConfig) => internalValidateHostConfig(hostConfig, { requiredProps: ["apiKey"], optionalProps: [] })
};

// src/http/http-functions.ts
var QLIK_CSRF_TOKEN = "qlik-csrf-token";
function clearCsrfToken(hostConfig) {
  const locationUrl = toValidLocationUrl(hostConfig);
  delete csrfTokens[locationUrl];
}
async function getCsrfToken(hostConfig, noCache) {
  const locationUrl = toValidLocationUrl(hostConfig);
  let pathTemplate;
  if (await isWindows(hostConfig)) {
    pathTemplate = "/qps/csrftoken";
  } else {
    pathTemplate = "/api/v1/csrf-token";
  }
  const fetchCsrfToken = async () => {
    const res = await invokeFetch("csrf-token", {
      method: "get",
      pathTemplate,
      options: {
        hostConfig,
        noCache: true
      }
    });
    const csrfToken = res.headers.get(QLIK_CSRF_TOKEN);
    if (!csrfToken) {
      return "";
    }
    return csrfToken;
  };
  if (noCache) {
    csrfTokens[locationUrl] = fetchCsrfToken();
    return csrfTokens[locationUrl];
  }
  csrfTokens[locationUrl] = csrfTokens[locationUrl] || fetchCsrfToken();
  return csrfTokens[locationUrl];
}
var csrfTokens = {};

// src/auth/internal/default-auth-modules/cookie.ts
function isModifyingVerb(verb) {
  return !(verb === "get" || verb === "GET");
}
async function getRestCallAuthParams4({
  hostConfig,
  method
}) {
  const headers = {};
  if (isModifyingVerb(method)) {
    headers["qlik-csrf-token"] = await getCsrfToken(hostConfig);
  }
  if (hostConfig.webIntegrationId) {
    headers["qlik-web-integration-id"] = hostConfig.webIntegrationId;
  }
  return { headers, queryParams: {}, credentials: getCredentialsForCookieAuth(hostConfig) };
}
async function getWebSocketAuthParams4({
  hostConfig
}) {
  const params = {
    // Bypass the cache to get one rest call out the door that can catch a 401 since the websocket only returns a general error
    "qlik-csrf-token": await getCsrfToken(hostConfig, true)
  };
  if (hostConfig.webIntegrationId) {
    params["qlik-web-integration-id"] = hostConfig.webIntegrationId;
  }
  return { queryParams: params };
}
async function handleAuthenticationError4({
  hostConfig,
  status
}) {
  clearCsrfToken(hostConfig);
  if (status === 403) {
    return {
      preventDefault: false,
      retry: true
    };
  }
  const webIntegrationParam = hostConfig.webIntegrationId ? `qlik-web-integration-id=${hostConfig?.webIntegrationId}&` : "";
  const locationUrl = toValidLocationUrl(hostConfig);
  if (hostConfig.authRedirectUserConfirmation) {
    await hostConfig.authRedirectUserConfirmation();
  }
  globalThis.location.replace(
    `${locationUrl}/login?${webIntegrationParam}returnto=${encodeURIComponent(globalThis.location.href)}`
  );
  return {
    preventDefault: true
  };
}
var cookie_default = {
  getRestCallAuthParams: getRestCallAuthParams4,
  getWebSocketAuthParams: getWebSocketAuthParams4,
  handleAuthenticationError: handleAuthenticationError4,
  validateHostConfig: (hostConfig) => internalValidateHostConfig(hostConfig, {
    requiredProps: [],
    optionalProps: ["webIntegrationId", "crossSiteCookies", "anonymousMode"]
  })
};

// src/auth/internal/default-auth-modules/none.ts
function getRestCallAuthParams5() {
  return Promise.resolve({ headers: {}, queryParams: {}, credentials: "same-origin" });
}
function getWebSocketAuthParams5() {
  return Promise.resolve({ queryParams: {} });
}
function handleAuthenticationError5() {
  return Promise.resolve({});
}
var none_default = {
  getRestCallAuthParams: getRestCallAuthParams5,
  getWebSocketAuthParams: getWebSocketAuthParams5,
  handleAuthenticationError: handleAuthenticationError5,
  validateHostConfig: (hostConfig) => internalValidateHostConfig(hostConfig, { requiredProps: [], optionalProps: [] })
};

// src/auth/internal/default-auth-modules/oauth/callback.ts
function handleOAuthCallback() {
  const urlParams = new URLSearchParams(globalThis.location.search);
  const callbackCode = urlParams.get("code") || void 0;
  const callbackState = urlParams.get("state") || void 0;
  if (urlParams.get("error")) {
    const element = document.createElement("pre");
    element.innerText = `<code>${JSON.stringify({
      error: urlParams.get("error"),
      error_code: urlParams.get("error_code"),
      error_description: urlParams.get("error_description"),
      error_detail: urlParams.get("error_detail"),
      error_uri: urlParams.get("error_uri")
    })}</code>`;
    document.body.prepend(element);
  }
  const topic = loadAndDeleteFromSessionStorage("", "client-in-progress");
  if (topic && callbackCode && callbackState) {
    const stateFromLocalStorage = loadAndDeleteFromSessionStorage(topic, "state");
    const finalRedirectUri = loadAndDeleteFromSessionStorage(topic, "href");
    if (stateFromLocalStorage && stateFromLocalStorage === callbackState && finalRedirectUri) {
      saveInSessionStorage(topic, "code", callbackCode);
      if (finalRedirectUri !== globalThis.location.href) {
        globalThis.location.replace(finalRedirectUri);
      }
    }
  }
}

// src/auth/internal/default-auth-modules/oauth.ts
if (isBrowser()) {
  handleOAuthCallback();
}
async function handlePotentialAuthenticationErrorAndRetry2(hostConfig, fn) {
  try {
    return await fn();
  } catch (err) {
    const { retry } = await handleAuthenticationError6({
      hostConfig,
      canRetry: true
    });
    if (retry) {
      return fn();
    }
    throw err;
  }
}
async function getRestCallAuthParams6({
  hostConfig
}) {
  return {
    headers: {
      Authorization: `Bearer ${await getOAuthAccessToken(hostConfig)}`
    },
    queryParams: {},
    credentials: "omit"
  };
}
async function getWebSocketAuthParams6({
  hostConfig
}) {
  const websocketAccessToken = await handlePotentialAuthenticationErrorAndRetry2(hostConfig, async () => {
    const accessToken = await getOAuthAccessToken(hostConfig);
    return exchangeAccessTokenForTemporaryToken(hostConfig, accessToken, "websocket");
  });
  return {
    queryParams: {
      accessToken: websocketAccessToken
    }
  };
}
async function getWebResourceAuthParams3({
  hostConfig
}) {
  const webResourceAccessToken = await handlePotentialAuthenticationErrorAndRetry2(hostConfig, async () => {
    const accessToken = await getOAuthAccessToken(hostConfig);
    return exchangeAccessTokenForTemporaryToken(hostConfig, accessToken, "webresource");
  });
  return {
    queryParams: {
      accessToken: webResourceAccessToken
    }
  };
}
async function handleAuthenticationError6({
  hostConfig
}) {
  if (hostConfig.getAccessToken) {
    clearStoredOauthTokens(hostConfig);
    return {
      preventDefault: false,
      retry: true
    };
  }
  if (isBrowser()) {
    if (hostConfig.performInteractiveLogin) {
      clearStoredOauthTokens(hostConfig);
      return {
        retry: true
      };
    }
    if (hostConfig.authRedirectUserConfirmation) {
      await hostConfig.authRedirectUserConfirmation();
    }
    startFullPageLoginFlow(hostConfig);
    return {
      preventDefault: true
    };
  }
  await refreshAccessToken(hostConfig);
  return {
    preventDefault: false,
    retry: true
  };
}
var oauth_default = {
  getRestCallAuthParams: getRestCallAuthParams6,
  getWebSocketAuthParams: getWebSocketAuthParams6,
  getWebResourceAuthParams: getWebResourceAuthParams3,
  handleAuthenticationError: handleAuthenticationError6,
  validateHostConfig: (hostConfig) => internalValidateHostConfig(hostConfig, {
    requiredProps: ["clientId"],
    optionalProps: [
      "clientSecret",
      "redirectUri",
      "accessTokenStorage",
      "scope",
      "subject",
      "userId",
      "noCache",
      "getAccessToken",
      "performInteractiveLogin"
    ]
  })
};

// src/auth/internal/default-auth-modules/windows-cookie/xrf-keys.ts
var xrfKeys = {};
function createXrfKey() {
  let result2 = "";
  for (let i = 0; i < 16; i += 1) {
    const j = Math.floor(Math.random() * 62);
    if (j < 10) {
      result2 += j;
    } else if (j > 9 && j < 36) {
      result2 += String.fromCharCode(j + 55);
    } else {
      result2 += String.fromCharCode(j + 61);
    }
  }
  return result2;
}
function getXrfKey(hostConfig) {
  const locationUrl = toValidLocationUrl(hostConfig);
  xrfKeys[locationUrl] = xrfKeys[locationUrl] || createXrfKey();
  return xrfKeys[locationUrl];
}

// src/auth/internal/default-auth-modules/windows-cookie.ts
async function getRestCallAuthParams7({
  hostConfig
}) {
  return {
    headers: {
      "X-Qlik-XrfKey": getXrfKey(hostConfig)
    },
    queryParams: {
      xrfkey: getXrfKey(hostConfig)
    },
    credentials: getCredentialsForCookieAuth(hostConfig)
  };
}
async function getWebSocketAuthParams7({
  hostConfig
}) {
  return {
    queryParams: {
      xrfkey: getXrfKey(hostConfig),
      "qlik-csrf-token": await getCsrfToken(hostConfig, true)
    }
  };
}
async function handleAuthenticationError7({
  hostConfig
}) {
  if (hostConfig.loginUri) {
    if (hostConfig.authRedirectUserConfirmation) {
      await hostConfig.authRedirectUserConfirmation();
    }
    globalThis.location.replace(
      hostConfig.loginUri.replace("{location}", encodeURIComponent(globalThis.location.href))
    );
    return {
      preventDefault: true
    };
  }
  return {
    // Do nothing, just let the error be thrown to calling code
  };
}
var windows_cookie_default = {
  getRestCallAuthParams: getRestCallAuthParams7,
  getWebSocketAuthParams: getWebSocketAuthParams7,
  handleAuthenticationError: handleAuthenticationError7,
  validateHostConfig: (hostConfig) => internalValidateHostConfig(hostConfig, {
    requiredProps: [],
    optionalProps: ["loginUri", "crossSiteCookies"]
  })
};

// src/auth/auth.ts
globalThis.loggingOut = false;
var authModulesRegistered = false;
function registerDefaultAuthModules() {
  if (!authModulesRegistered) {
    registerAuthModule("apikey", apikey_default);
    registerAuthModule("cookie", cookie_default);
    registerAuthModule("none", none_default);
    registerAuthModule("oauth2", oauth_default);
    registerAuthModule("anonymous", anonymous_default);
    registerAuthModule("windowscookie", windows_cookie_default);
    authModulesRegistered = true;
  }
}
registerDefaultAuthModules();
var auth = {
  logout,
  registerAuthModule,
  setDefaultHostConfig: setDefaultHostConfig2,
  getRestCallAuthParams,
  getWebSocketAuthParams,
  getWebResourceAuthParams,
  handleAuthenticationError,
  toValidLocationUrl,
  toValidEnigmaLocationUrl,
  toValidWebsocketLocationUrl,
  isWindows,
  isHostCrossOrigin
};
var auth_default = auth;

// src/invoke-fetch/internal/invoke-fetch-helpers.ts
function encodeQueryParams(query) {
  if (query) {
    return Object.entries(query).map((kv) => {
      const [, value] = kv;
      if (value === void 0) {
        return void 0;
      }
      return kv.map(
        (val) => (
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          encodeURIComponent(val)
        )
      ).join("=");
    }).filter(Boolean).join("&");
  }
  return "";
}
function applyPathVariables(pathTemplate, pathVariables) {
  let result2 = pathTemplate;
  if (pathVariables) {
    Object.keys(pathVariables).forEach((key) => {
      result2 = result2.replace(`{${key}}`, pathVariables[key]);
    });
  }
  return result2;
}
function toCacheKey(url, query, serializedHostConfig, headers) {
  let cacheKey = url;
  if (query !== "") {
    cacheKey = cacheKey.concat(`?${query}`);
  }
  if (headers) {
    cacheKey = cacheKey.concat(`+headers=${JSON.stringify(headers)}`);
  }
  if (serializedHostConfig) {
    cacheKey = cacheKey.concat(`+host-config=${serializedHostConfig}`);
  }
  return cacheKey;
}
function toCompleteUrl(url, query) {
  if (query !== "") {
    return `${url}?${query}`;
  }
  return url;
}
function shouldUseCachedResult(options, cacheEntry, defaultMaxCacheTime) {
  if (!cacheEntry || typeof cacheEntry.value === void 0) {
    return false;
  }
  if (options?.noCache) {
    return false;
  }
  if (options?.useCacheIfAfter) {
    return options.useCacheIfAfter.getTime() <= cacheEntry.lastPulled;
  }
  const age = Date.now() - cacheEntry.lastPulled;
  if (options?.maxCacheAge) {
    return age <= options?.maxCacheAge;
  }
  return age < defaultMaxCacheTime;
}
var shouldPopulateCache = (method) => method === "get" || method === "GET";
function clone(value) {
  if (value && (value instanceof Blob || value instanceof Object && value.toString() === "[object Blob]")) {
    return value;
  }
  if (value && value instanceof ReadableStream) {
    return value;
  }
  if (typeof value === "string") {
    return value;
  }
  return JSON.parse(JSON.stringify(value));
}
function isModifyingVerb2(verb) {
  return !(verb === "get" || verb === "GET");
}
function cacheKeyToUrl(cachedUrl) {
  const queryIdx = cachedUrl.indexOf("?");
  if (queryIdx >= 0) {
    return cachedUrl.substring(0, queryIdx);
  }
  const headersIdx = cachedUrl.indexOf("+headers=");
  if (headersIdx >= 0) {
    return cachedUrl.substring(0, headersIdx);
  }
  const hostConfigIdx = cachedUrl.indexOf("+host-config=");
  if (hostConfigIdx >= 0) {
    return cachedUrl.substring(0, hostConfigIdx);
  }
  return cachedUrl;
}
function clearRelatedCacheEntries(cache2, cacheKey) {
  const modifyingUrl = cacheKeyToUrl(cacheKey);
  for (const existingCacheKey in cache2) {
    const cleanUrl = cacheKeyToUrl(existingCacheKey);
    if (
      // Either up or down the path...
      modifyingUrl.startsWith(cleanUrl) || cleanUrl.startsWith(modifyingUrl)
    ) {
      delete cache2[existingCacheKey];
    }
  }
}
function cloneResultPromise(value) {
  return value.then((resp) => {
    const result2 = {
      data: clone(resp.data),
      headers: resp.headers,
      status: resp.status
    };
    if (resp.next) {
      result2.next = resp.next;
    }
    if (resp.prev) {
      result2.prev = resp.prev;
    }
    return result2;
  });
}
function clearCacheOnError(cacheEntry, cacheKey, value) {
  return value.catch((error) => {
    delete cacheEntry[cacheKey];
    return Promise.reject(error);
  });
}

// src/invoke-fetch/internal/invoke-fetch-methods.ts
var defaultCacheTime = 1e3 * 60 * 10;
var cache = {};
globalThis.__API_CACHE__DO_NOT_USE_OR_YOU_WILL_BE_FIRED = cache;
function clearApiCacheInternal(api) {
  cache[api] = {};
}
function getErrorMessage(error) {
  if (error instanceof Error) {
    if (error.cause) {
      if (error.message) {
        return `${error.message} - ${getErrorMessage(error.cause)}`;
      }
      return getErrorMessage(error.cause);
    }
    return error.message;
  }
  return String(error);
}
async function fetchAndTransformExceptions(input, init) {
  try {
    return await fetch(input, init);
  } catch (e) {
    return Promise.reject(new InvokeFetchError(getErrorMessage(e), 0, new Headers(), {}));
  }
}
async function performActualHttpFetch(method, completeUrl, unencodedBody, contentType, options, authHeaders, credentials, userAgent) {
  const { body, contentTypeHeader, requestOptions } = encodeBody(unencodedBody, contentType ?? "");
  const headers = {
    ...contentTypeHeader,
    ...authHeaders,
    ...options?.headers,
    ...getServiceOverrideHeaderFromLocalStorage()
  };
  if (!headers["User-Agent"] && userAgent) {
    headers["User-Agent"] = userAgent;
  }
  const isCrossOrigin = isHostCrossOrigin(options?.hostConfig);
  const request = {
    method,
    credentials,
    mode: isCrossOrigin ? "cors" : "same-origin",
    headers,
    redirect: await isWindows(options?.hostConfig) ? "manual" : "follow",
    keepalive: options?.keepalive,
    body,
    // body data type must match "Content-Type" header
    ...requestOptions
    // This adds 'duplex: "half"' if we're sending application/octet-stream, needed in node only.
  };
  let fetchTimeoutId;
  if (options?.signal) {
    request.signal = options.signal;
  } else if (options?.timeoutMs && options.timeoutMs > 0) {
    const controller = new AbortController();
    fetchTimeoutId = setTimeout(() => {
      controller.abort();
    }, options.timeoutMs);
    request.signal = controller.signal;
  }
  const fetchResponse = await fetchAndTransformExceptions(completeUrl, request);
  if (fetchTimeoutId) {
    clearTimeout(fetchTimeoutId);
  }
  const invokeFetchResponse = await parseFetchResponse(fetchResponse, completeUrl);
  return invokeFetchResponse;
}
function encodeBody(unencodedBody, contentType) {
  if (!unencodedBody) {
    return { body: null, contentTypeHeader: {}, requestOptions: {} };
  }
  const contentTypeHeader = {};
  const requestOptions = {};
  let body = null;
  switch (contentType) {
    case "":
    case "application/json":
      contentTypeHeader["Content-Type"] = "application/json";
      body = JSON.stringify(unencodedBody);
      break;
    case "multipart/form-data":
      body = encodeMultipartBody(unencodedBody);
      break;
    case "application/octet-stream":
      contentTypeHeader["Content-Type"] = contentType;
      requestOptions["duplex"] = "half";
      body = unencodedBody;
      break;
    case "text/plain":
      if (typeof unencodedBody === "string") {
        contentTypeHeader["Content-Type"] = contentType;
        body = unencodedBody;
      } else {
        throw new EncodingError(
          `Cannot send ${typeof unencodedBody} as ${contentType}, body should be a string.`,
          contentType,
          unencodedBody
        );
      }
      break;
    default:
      throw new EncodingError(
        `Unsupported content-type "${contentType}", supported are: application/json, multipart/form-data, application/octet-stream and text/plain`,
        contentType,
        unencodedBody
      );
  }
  return { body, contentTypeHeader, requestOptions };
}
function encodeMultipartBody(unencodedBody) {
  const contentType = "multipart/form-data";
  if (typeof unencodedBody !== "object") {
    throw new EncodingError(
      `Cannot encode ${typeof unencodedBody} as ${contentType}, body should be an object.`,
      contentType,
      unencodedBody
    );
  }
  if (Array.isArray(unencodedBody)) {
    throw new EncodingError(
      `Cannot encode ${typeof unencodedBody} as ${contentType}, body should be an object.`,
      contentType,
      unencodedBody
    );
  }
  if (unencodedBody instanceof FormData) {
    return unencodedBody;
  }
  const form = new FormData();
  Object.entries(unencodedBody).forEach((entry) => {
    const [key, value] = entry;
    switch (typeof value) {
      case "boolean":
      case "number":
      case "string":
        form.set(key, `${value}`);
        break;
      case "object":
        if (value instanceof Blob) {
          form.set(key, value);
        } else if (value instanceof Uint8Array) {
          const data = new Blob([value], { type: "application/octet-stream" });
          form.set(key, data);
        } else {
          const json = JSON.stringify(value);
          const data = new Blob([json], { type: "application/json" });
          form.set(key, data, "");
        }
        break;
      default:
        throw new EncodingError(
          `Cannot encode multipart-field "${key}" with value of type ${typeof value}, values must be objects, strings, numbers or boolean.`,
          contentType,
          unencodedBody
        );
    }
  });
  return form;
}
async function getInvokeFetchUrlParams({
  method,
  pathTemplate,
  pathVariables,
  query,
  options
}) {
  const locationUrl = toValidLocationUrl(options?.hostConfig);
  const {
    headers: authHeaders,
    queryParams: authQueryParams,
    credentials
  } = await getRestCallAuthParams({
    hostConfig: options?.hostConfig,
    method
  });
  const url = locationUrl + applyPathVariables(pathTemplate, pathVariables);
  const queryString = encodeQueryParams({ ...query, ...authQueryParams });
  const completeUrl = toCompleteUrl(url, queryString);
  const cacheKey = toCacheKey(url, queryString, serializeHostConfig(options?.hostConfig), options?.headers);
  return { completeUrl, cacheKey, authHeaders, credentials };
}
function invokeFetchWithUrl(api, props) {
  return invokeFetchWithUrlAndRetry(api, props, async () => {
    const { cacheKey, authHeaders, credentials } = await getInvokeFetchUrlParams(props);
    return invokeFetchWithUrlAndRetry(
      api,
      { ...props, cacheKey, authHeaders, credentials, options: { ...props.options, noCache: true } },
      // don't cache the retry
      void 0
      // only retry once
    );
  });
}
function invokeFetchWithUrlAndRetry(api, {
  method,
  completeUrl,
  cacheKey,
  body,
  options,
  authHeaders,
  credentials,
  contentType,
  userAgent
}, performRetry) {
  if (!cache[api]) {
    cache[api] = {};
  }
  const cacheEntry = isModifyingVerb2(method) ? void 0 : cache[api][cacheKey];
  if (isModifyingVerb2(method)) {
    clearRelatedCacheEntries(cache[api], cacheKey);
  }
  if (cacheEntry && shouldUseCachedResult(options, cacheEntry, defaultCacheTime)) {
    cacheEntry.lastHit = /* @__PURE__ */ new Date();
    cacheEntry.hitCount += 1;
    cacheEntry.accessedPaths.add(globalThis.location ? globalThis.location.pathname : "node");
    return cloneResultPromise(cacheEntry.value);
  }
  const resultPromiseFromBackend = performActualHttpFetch(
    method,
    completeUrl,
    body,
    contentType,
    options,
    authHeaders,
    credentials,
    userAgent
  );
  const resultAfterAuthenticationCheck = interceptAuthenticationErrors(
    options?.hostConfig,
    resultPromiseFromBackend,
    performRetry
  );
  const resultPromiseAfterPagingAddon = addPagingFunctions(
    api,
    resultAfterAuthenticationCheck,
    method,
    body,
    options,
    authHeaders,
    credentials
  );
  const resultPromiseAfterCacheClearing = clearCacheOnError(cache[api], cacheKey, resultPromiseAfterPagingAddon);
  if (shouldPopulateCache(method)) {
    if (Object.hasOwn && !Object.hasOwn(cache, api) || api === "__proto__") {
      throw new Error(`Forbidden api name: ${api}`);
    }
    cache[api][cacheKey] = {
      lastPulled: Date.now(),
      value: resultPromiseAfterCacheClearing,
      lastHit: null,
      hitCount: 0,
      accessedPaths: /* @__PURE__ */ new Set()
    };
  }
  return cloneResultPromise(resultPromiseAfterCacheClearing);
}
function addPagingFunctions(api, value, method, body, options, authHeaders, credentials) {
  const serializedHostConfig = serializeHostConfig(options?.hostConfig);
  return value.then((resp) => {
    const dataWithPotentialLinks = resp.data;
    if (!dataWithPotentialLinks) {
      return resp;
    }
    const prevUrl = dataWithPotentialLinks.links?.prev?.href;
    const nextUrl = dataWithPotentialLinks.links?.next?.href;
    if (prevUrl) {
      resp.prev = (prevOptions) => invokeFetchWithUrl(api, {
        method,
        completeUrl: prevUrl,
        body,
        options: prevOptions || options,
        cacheKey: toCacheKey(prevUrl, "", serializedHostConfig, options?.headers),
        authHeaders,
        credentials
      });
    }
    if (nextUrl) {
      resp.next = (nextOptions) => invokeFetchWithUrl(api, {
        method,
        completeUrl: nextUrl,
        body,
        options: nextOptions || options,
        cacheKey: toCacheKey(nextUrl, "", serializedHostConfig, options?.headers),
        authHeaders,
        credentials
      });
    }
    return resp;
  });
}
function neverResolvingPromise() {
  return new Promise(() => {
  });
}
async function interceptAuthenticationErrors(hostConfig, resultPromise, performRetry) {
  try {
    return await resultPromise;
  } catch (error) {
    const err = error;
    const errorBody = err.data;
    if (err.status === 401 || err.status === 403 && errorBody?.code === "CSRF-TOKEN-2" || (err.status === 301 || err.status === 302) && await isWindows(hostConfig)) {
      if (globalThis.loggingOut) {
        return neverResolvingPromise();
      }
      const { retry, preventDefault } = await handleAuthenticationError({
        hostConfig,
        status: err.status,
        headers: err.headers,
        errorBody,
        canRetry: !!performRetry
      });
      if (retry && performRetry) {
        return performRetry();
      }
      if (preventDefault) {
        return neverResolvingPromise();
      }
    }
    throw error;
  }
}
function getServiceOverrideHeaderFromLocalStorage() {
  if (!isBrowser()) {
    return {};
  }
  const header = localStorage.getItem("qmfe-api-service-overrides-header");
  if (!header) {
    return {};
  }
  return { "X-Qlik-Overrides": header };
}
function toDownloadableBlob(blob, name) {
  const result2 = blob;
  if (name) {
    result2.download = (filename = name) => download(blob, filename);
  } else {
    result2.download = (filename) => download(blob, filename);
  }
  return result2;
}
async function download(blob, filename) {
  if (isBrowser()) {
    const a = document.createElement("a");
    const blobUrl = window.URL.createObjectURL(blob);
    a.href = blobUrl;
    a.download = filename;
    a.click();
    window.URL.revokeObjectURL(blobUrl);
  } else {
    const { writeFileSync } = await import("fs");
    const arrayBuffer = await blob.arrayBuffer();
    const uint8Array = new Uint8Array(arrayBuffer);
    writeFileSync(filename, uint8Array);
  }
}

// src/invoke-fetch/invoke-fetch-error.ts
var InvokeFetchError = class extends Error {
  status;
  headers;
  data;
  constructor(errorMessage, status, headers, data) {
    super(errorMessage);
    this.status = status;
    this.headers = headers;
    this.data = data;
    this.stack = cleanStack(this.stack);
  }
};
var EncodingError = class extends Error {
  contentType;
  data;
  constructor(errorMessage, contentType, data) {
    super(errorMessage);
    this.contentType = contentType;
    this.data = data;
    this.stack = cleanStack(this.stack);
  }
};
var regex = /^.+\/qmfe-api(?:\.js)?:(\d+)(?::\d+)?$/gim;
var isFromQmfeApi = (line) => {
  const matches = line.match(regex);
  return Boolean(matches && matches.length > 0);
};
function cleanStack(stack) {
  if (!stack) {
    return stack;
  }
  const newStack = [];
  const lines = stack.split("\n");
  lines.reverse();
  for (const line of lines) {
    if (isFromQmfeApi(line)) {
      break;
    }
    newStack.unshift(line);
  }
  return newStack.join("\n");
}

// src/invoke-fetch/invoke-fetch-functions.ts
var defaultUserAgent = "qmfe-api/latest";
async function invokeFetch(api, props, interceptors) {
  interceptors = interceptors || getInterceptors();
  const invokeFetchFinal = (reqeust) => invokeFetchIntercepted(api, reqeust);
  const withInterceptors = (interceptors || []).reduce(
    (proceed, interceptor) => (request) => interceptor(request, proceed),
    invokeFetchFinal
  );
  return withInterceptors(props);
}
async function invokeFetchIntercepted(api, props) {
  checkForCrossDomainRequest(props.options?.hostConfig);
  let userAgent;
  if (props?.userAgent) {
    userAgent = props.userAgent;
  } else if (isBrowser()) {
    userAgent = `${window.navigator.userAgent} ${defaultUserAgent}`;
  } else {
    userAgent = defaultUserAgent;
  }
  const { completeUrl, cacheKey, authHeaders, credentials } = await getInvokeFetchUrlParams(props);
  return invokeFetchWithUrl(api, {
    ...props,
    method: props.method.toUpperCase(),
    completeUrl,
    cacheKey,
    authHeaders,
    credentials,
    userAgent
  });
}
function clearApiCache(api) {
  clearApiCacheInternal(api);
}
async function parseFetchResponse(fetchResponse, url) {
  let resultData;
  const contentType = fetchResponse.headers.get("content-type")?.split(";")[0];
  const contentDisposition = fetchResponse.headers.get("content-disposition")?.split(";");
  if (contentDisposition && contentDisposition[0] === "attachment") {
    let filename = "";
    for (let i = 1; i < contentDisposition.length; i++) {
      const attr = contentDisposition[i].trim();
      if (attr.indexOf("filename") === 0) {
        const start = attr.indexOf('"');
        const end = attr.lastIndexOf('"');
        filename = attr.slice(start + 1, end);
      }
    }
    resultData = toDownloadableBlob(await fetchResponse.blob(), filename);
  } else {
    switch (contentType) {
      // Note: This list is by no means exhaustive, populate with more types as needed.
      case "image/png":
      case "image/jpeg":
      case "image/x-icon":
      case "application/offset+octet-stream":
      case "application/octet-stream":
      case "application/zip":
      case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
      case "application/pdf":
        resultData = toDownloadableBlob(await fetchResponse.blob());
        break;
      case "text/event-stream":
        resultData = fetchResponse.body;
        break;
      default:
        try {
          resultData = await fetchResponse.text();
          resultData = JSON.parse(resultData);
        } catch {
        }
        break;
    }
  }
  const { status, statusText, headers } = fetchResponse;
  const errorMsg = `request to '${url}' failed with status ${status} ${statusText}.`;
  if (status >= 300) {
    throw new InvokeFetchError(errorMsg, status, headers, resultData);
  }
  if (status === 0) {
    throw new InvokeFetchError(errorMsg, 302, headers, resultData);
  }
  const invokeFetchResponse = {
    status,
    headers,
    data: resultData
  };
  return invokeFetchResponse;
}

// src/invoke-fetch/invoke-fetch.ts
var invokeFetchExp = {
  invokeFetch,
  clearApiCache,
  parseFetchResponse
};
var invoke_fetch_default = invokeFetchExp;

export {
  getPlatform,
  InvalidHostConfigError,
  UnexpectedAuthTypeError,
  InvalidAuthTypeError,
  AuthorizationError,
  isHostCrossOrigin,
  isWindows,
  toValidLocationUrl,
  toValidEnigmaLocationUrl,
  toValidWebsocketLocationUrl,
  getWebSocketAuthParams,
  getWebResourceAuthParams,
  handleAuthenticationError,
  getRestCallAuthParams,
  getAccessToken,
  registerAuthModule2 as registerAuthModule,
  setDefaultHostConfig2 as setDefaultHostConfig,
  serializeHostConfig,
  checkForCrossDomainRequest,
  logout,
  generateRandomString,
  InvokeFetchError,
  EncodingError,
  invokeFetch,
  clearApiCache,
  parseFetchResponse,
  invoke_fetch_default,
  auth_default
};
