// src/platform/platform-functions.ts
var getPlatform = async (options = {}) => {
  const isNodeEnvironment = typeof window === "undefined";
  if (isNodeEnvironment) {
    return result({ isNodeEnv: true });
  }
  const { data: productInfo, status } = await getProductInfo(options);
  if (status === 404) {
    return result({ isUnknown: true });
  }
  if (!productInfo || status <= 399 && status >= 300) {
    return result({ isQSE: true, isWindows: true });
  }
  const deploymentType = (productInfo.composition?.deploymentType || "").toLowerCase();
  if (deploymentType === "qliksenseserver") {
    return result({ isQSE: true, isWindows: true });
  }
  if (deploymentType === "qliksensedesktop") {
    return result({ isQSD: true, isWindows: true });
  }
  if (productInfo.composition?.provider === "fedramp") {
    return result({ isCloud: true, isQCG: true });
  }
  return result({ isCloud: true, isQCS: true });
};
var productInfoPromises = {};
function templateUrl(baseUrl) {
  return `${baseUrl}/resources/autogenerated/product-info.json`;
}
var getProductInfo = async ({ hostConfig, noCache } = {}) => {
  const url = toValidLocationUrl(hostConfig);
  const completeUrl = templateUrl(url);
  try {
    if (!(completeUrl in productInfoPromises)) {
      const fetchOptions = {};
      if (globalThis.QlikMain && globalThis.QlikMain.resourceNeedsCredentials(completeUrl)) {
        fetchOptions.credentials = "include";
      }
      const productInfoPromise = fetch(completeUrl, fetchOptions).then(async (res) => {
        if (res.ok) {
          return { data: await res.json(), status: res.status };
        }
        return { data: void 0, status: res.status };
      });
      productInfoPromises[completeUrl] = productInfoPromise;
    }
    const response = await productInfoPromises[completeUrl];
    if (response.status >= 400 || !response.data) {
      delete productInfoPromises[completeUrl];
    }
    return response;
  } catch (err) {
    delete productInfoPromises[completeUrl];
    return { data: void 0, status: 500 };
  } finally {
    if (noCache) {
      delete productInfoPromises[completeUrl];
    }
  }
};
var result = (data) => ({
  isNodeEnv: false,
  isCloud: false,
  isQCS: false,
  isQCG: false,
  isWindows: false,
  isQSE: false,
  isQSD: false,
  isUnknown: false,
  ...data
});

// src/auth/internal/default-host-config.ts
var defaultHostConfig = {};
function setDefaultHostConfig(hostConfig) {
  defaultHostConfig = hostConfig || {};
}
function withDefaultHostConfig(hostConfig) {
  return hostConfig || defaultHostConfig;
}

// src/auth/internal/auth-module-registry.ts
var authModules = {};
var ongoingAuthModuleLoading = Promise.resolve();
function registerAuthModule(name, authModule) {
  authModules[name.toLowerCase()] = authModule;
}
function getRegisteredAuthModules() {
  return Object.keys(authModules);
}
function getRegisteredAuthModule(authType) {
  return authModules[authType.toLowerCase()];
}
async function getAuthModule(hostConfig) {
  const hostConfigToUse = withDefaultHostConfig(hostConfig);
  const authType = await guessAuthTypeIfMissing(hostConfigToUse);
  if (ongoingAuthModuleLoading) {
    await ongoingAuthModuleLoading;
  }
  let authModule = getRegisteredAuthModule(authType);
  if (!authModule) {
    ongoingAuthModuleLoading = (async () => {
      authModule = await resolveGloballyDefinedAuthModule(authType);
      if (authModule) {
        registerAuthModule(authType, authModule);
      }
    })();
    await ongoingAuthModuleLoading;
  }
  if (!authModule) {
    throw new InvalidAuthTypeError(authType);
  }
  if (authModule.validateHostConfig) {
    authModule.validateHostConfig({ authType, ...hostConfigToUse });
  }
  return authModule;
}
async function guessAuthTypeIfMissing(hostConfig) {
  if (hostConfig.authType) {
    return hostConfig.authType;
  }
  if (hostConfig.apiKey) {
    return "apikey";
  }
  if (hostConfig.clientId) {
    return "oauth2";
  }
  if (hostConfig.webIntegrationId) {
    return "cookie";
  }
  if (await isWindows(hostConfig)) {
    return "windowscookie";
  }
  return "cookie";
}
async function resolveGloballyDefinedAuthModule(authType) {
  const globalWindow = globalThis;
  const globalVariable = globalWindow[authType];
  if (globalVariable) {
    let potentialAuthModule;
    if (typeof globalVariable === "function") {
      potentialAuthModule = await globalVariable();
    } else {
      potentialAuthModule = globalVariable;
    }
    if (potentialAuthModule && potentialAuthModule.getRestCallAuthParams && potentialAuthModule.getWebSocketAuthParams && potentialAuthModule.handleAuthenticationError) {
      return potentialAuthModule;
    }
    console.error("Not a valid auth module", potentialAuthModule);
    throw new InvalidAuthTypeError(authType);
  }
  return Promise.resolve(void 0);
}

// src/auth/auth-errors.ts
var InvalidHostConfigError = class extends Error {
  constructor(message) {
    super(`Invalid host config: ${message}`);
    this.name = "InvalidHostConfigError";
  }
};
var UnexpectedAuthTypeError = class extends Error {
  constructor(...expectedAuthTypes) {
    const ors = expectedAuthTypes.map((item, index) => index === 0 ? `"${item}"` : `or "${item}"`).join(" ");
    super(`HostConfig is not properly configured. authType is expected to be ${ors}`);
    this.name = "UnexpectedAuthTypeError";
  }
};
var InvalidAuthTypeError = class extends Error {
  constructor(authType) {
    const validAuthModules = getRegisteredAuthModules();
    super(
      `Not a valid auth type: ${authType}, valid auth types are; '${validAuthModules.filter((name) => name !== "QmfeEmbedFramerAuthModule").join("', '")}'`
    );
    this.name = "InvalidAuthTypeError";
  }
};

// src/auth/auth-functions.ts
function isHostCrossOrigin(hostConfig) {
  if (!globalThis.location?.origin) {
    return true;
  }
  const hostConfigToUse = withDefaultHostConfig(hostConfig);
  if (Object.keys(hostConfigToUse).length === 0) {
    return false;
  }
  const locationUrl = toValidLocationUrl(hostConfigToUse);
  return !(locationUrl === "" || locationUrl.startsWith(globalThis.location.origin));
}
async function isWindows(hostConfig) {
  const hostConfigToUse = withDefaultHostConfig(hostConfig);
  if (hostConfigToUse.authType === "cookie") {
    return false;
  }
  if (hostConfigToUse.authType === "windowscookie") {
    return true;
  }
  return (await getPlatform({ hostConfig })).isWindows;
}
function toValidLocationUrl(hostConfig) {
  const url = withDefaultHostConfig(hostConfig)?.host;
  let locationUrl;
  if (!url) {
    locationUrl = "";
  } else if (url.toLowerCase().startsWith("https://") || url.toLowerCase().startsWith("http://")) {
    locationUrl = url;
  } else {
    locationUrl = `https://${url}`;
  }
  while (locationUrl[locationUrl.length - 1] === "/") {
    locationUrl = locationUrl.substring(0, locationUrl.length - 1);
  }
  return locationUrl;
}
function toValidEnigmaLocationUrl(hostConfig) {
  return toValidWebsocketLocationUrl(hostConfig);
}
function toValidWebsocketLocationUrl(hostConfig) {
  const url = withDefaultHostConfig(hostConfig)?.host;
  let locationUrl;
  if (!url) {
    locationUrl = globalThis.location.origin;
  } else if (url.toLowerCase().startsWith("https://") || url.toLowerCase().startsWith("http://")) {
    locationUrl = url;
  } else {
    locationUrl = `https://${url}`;
  }
  while (locationUrl[locationUrl.length - 1] === "/") {
    locationUrl = locationUrl.substring(0, locationUrl.length - 1);
  }
  return locationUrl.replace(leadingHttp, "ws");
}
async function getWebSocketAuthParams(props) {
  const hostConfigToUse = withDefaultHostConfig(props.hostConfig);
  return (await getAuthModule(hostConfigToUse)).getWebSocketAuthParams({
    ...props,
    hostConfig: hostConfigToUse
  });
}
async function getWebResourceAuthParams(props) {
  const hostConfigToUse = withDefaultHostConfig(props.hostConfig);
  return (await getAuthModule(hostConfigToUse)).getWebResourceAuthParams?.({
    ...props,
    hostConfig: hostConfigToUse
  }) || { queryParams: {} };
}
async function handleAuthenticationError(props) {
  const hostConfigToUse = withDefaultHostConfig(props.hostConfig);
  return (await getAuthModule(hostConfigToUse)).handleAuthenticationError({
    ...props,
    hostConfig: hostConfigToUse
  });
}
async function getRestCallAuthParams(props) {
  const hostConfigToUse = withDefaultHostConfig(props.hostConfig);
  return (await getAuthModule(hostConfigToUse)).getRestCallAuthParams({
    ...props,
    hostConfig: hostConfigToUse
  });
}
function registerAuthModule2(name, authModule) {
  registerAuthModule(name, authModule);
}
function setDefaultHostConfig2(hostConfig) {
  setDefaultHostConfig(hostConfig);
}
function checkForCrossDomainRequest(hostConfig) {
  const hostConfigToUse = withDefaultHostConfig(hostConfig);
  if (isHostCrossOrigin(hostConfigToUse)) {
    if (Object.keys(hostConfigToUse).length === 0) {
      throw new InvalidHostConfigError("a host config must be provided when making a cross domain request");
    }
    if (!hostConfigToUse.host) {
      throw new InvalidHostConfigError("A 'host' must be set in host config when making a cross domain request");
    }
  }
}
var logout = () => {
  globalThis.loggingOut = true;
  globalThis.location.href = "/logout";
};
var leadingHttp = /^http/;

// src/auth/internal/auth-functions.ts
function getCredentialsForCookieAuth(hostConfig) {
  if (hostConfig.crossSiteCookies === false) {
    return "same-origin";
  }
  if (isHostCrossOrigin(hostConfig)) {
    return "include";
  }
  return "same-origin";
}
function internalValidateHostConfig(hostConfig, options) {
  const missingRequiredProps = [];
  for (const requiredProp of options.requiredProps) {
    if (!hostConfig[requiredProp]) {
      missingRequiredProps.push(requiredProp);
    }
  }
  if (missingRequiredProps.length > 0) {
    throw new InvalidHostConfigError(
      `missing required properties in host config; '${missingRequiredProps.join("', '")}'`
    );
  }
  const validProps = [
    "authType",
    "autoRedirect",
    "authRedirectUserConfirmation",
    "embedRuntimeUrl",
    "host",
    ...options.requiredProps,
    ...options.optionalProps
  ];
  const invalidKeys = [];
  Object.keys(hostConfig).forEach((key) => {
    if (!validProps.some((k) => k === key)) {
      invalidKeys.push(key);
    }
  });
  if (invalidKeys.length > 0) {
    throw new InvalidHostConfigError(`unknown properties in host config; '${invalidKeys.join("', '")}'`);
  }
  return true;
}

// src/auth/internal/default-auth-modules/apikey.ts
function getRestCallAuthParams2({ hostConfig }) {
  return Promise.resolve({
    headers: {
      Authorization: `Bearer ${hostConfig?.apiKey}`
    },
    queryParams: {},
    credentials: "omit"
  });
}
async function getWebSocketAuthParams2() {
  return {
    queryParams: {
      // accessToken: hostConfig.apiKey,
    }
  };
}
function handleAuthenticationError2() {
  return Promise.resolve({});
}
var apikey_default = {
  getRestCallAuthParams: getRestCallAuthParams2,
  getWebSocketAuthParams: getWebSocketAuthParams2,
  handleAuthenticationError: handleAuthenticationError2,
  validateHostConfig: (hostConfig) => internalValidateHostConfig(hostConfig, { requiredProps: ["apiKey"], optionalProps: [] })
};

// src/http/http-functions.ts
var QLIK_CSRF_TOKEN = "qlik-csrf-token";
function clearCsrfToken(hostConfig) {
  const locationUrl = toValidLocationUrl(hostConfig);
  delete csrfTokens[locationUrl];
}
async function getCsrfToken(hostConfig, noCache) {
  const locationUrl = toValidLocationUrl(hostConfig);
  const fetchCsrfToken = async () => {
    const res = await invokeFetch("csrf-token", {
      method: "get",
      pathTemplate: "/api/v1/csrf-token",
      options: {
        hostConfig,
        noCache: true
      }
    });
    const csrfToken = res.headers.get(QLIK_CSRF_TOKEN);
    if (!csrfToken) {
      return "";
    }
    return csrfToken;
  };
  if (noCache) {
    csrfTokens[locationUrl] = fetchCsrfToken();
    return csrfTokens[locationUrl];
  }
  csrfTokens[locationUrl] = csrfTokens[locationUrl] || fetchCsrfToken();
  return csrfTokens[locationUrl];
}
var csrfTokens = {};

// src/auth/internal/default-auth-modules/cookie.ts
function isModifyingVerb(verb) {
  return !(verb === "get" || verb === "GET");
}
async function getRestCallAuthParams3({
  hostConfig,
  method
}) {
  const headers = {};
  if (isModifyingVerb(method)) {
    headers["qlik-csrf-token"] = await getCsrfToken(hostConfig);
  }
  if (hostConfig.webIntegrationId) {
    headers["qlik-web-integration-id"] = hostConfig.webIntegrationId;
  }
  return { headers, queryParams: {}, credentials: getCredentialsForCookieAuth(hostConfig) };
}
async function getWebSocketAuthParams3({
  hostConfig
}) {
  const params = {
    // Bypass the cache to get one rest call out the door that can catch a 401 since the websocket only returns a general error
    "qlik-csrf-token": await getCsrfToken(hostConfig, true)
  };
  if (hostConfig.webIntegrationId) {
    params["qlik-web-integration-id"] = hostConfig.webIntegrationId;
  }
  return { queryParams: params };
}
async function handleAuthenticationError3({
  hostConfig,
  status,
  errorBody = {}
}) {
  clearCsrfToken(hostConfig);
  if (status === 403) {
    return {
      preventDefault: false,
      // Only retry if the csrf token has expired
      retry: errorBody?.code === "CSRF-TOKEN-2"
    };
  }
  const webIntegrationParam = hostConfig.webIntegrationId ? `qlik-web-integration-id=${hostConfig?.webIntegrationId}&` : "";
  const locationUrl = toValidLocationUrl(hostConfig);
  if (hostConfig.authRedirectUserConfirmation) {
    await hostConfig.authRedirectUserConfirmation();
  }
  globalThis.location.replace(
    `${locationUrl}/login?${webIntegrationParam}returnto=${encodeURIComponent(globalThis.location.href)}`
  );
  return {
    preventDefault: true
  };
}
var cookie_default = {
  getRestCallAuthParams: getRestCallAuthParams3,
  getWebSocketAuthParams: getWebSocketAuthParams3,
  handleAuthenticationError: handleAuthenticationError3,
  validateHostConfig: (hostConfig) => internalValidateHostConfig(hostConfig, {
    requiredProps: [],
    optionalProps: ["webIntegrationId", "crossSiteCookies"]
  })
};

// src/auth/internal/default-auth-modules/none.ts
function getRestCallAuthParams4() {
  return Promise.resolve({ headers: {}, queryParams: {}, credentials: "same-origin" });
}
function getWebSocketAuthParams4() {
  return Promise.resolve({ queryParams: {} });
}
function handleAuthenticationError4() {
  return Promise.resolve({});
}
var none_default = {
  getRestCallAuthParams: getRestCallAuthParams4,
  getWebSocketAuthParams: getWebSocketAuthParams4,
  handleAuthenticationError: handleAuthenticationError4,
  validateHostConfig: (hostConfig) => internalValidateHostConfig(hostConfig, { requiredProps: [], optionalProps: [] })
};

// src/auth/internal/default-auth-modules/oauth/storage-helpers.ts
var storagePrefix = "qlik-qmfe-api";
var tokens = {};
function saveInLocalStorage(scope, name, value) {
  localStorage.setItem(`${storagePrefix}-${scope}-${name}`, value);
}
function saveInSessionStorage(scope, name, value) {
  sessionStorage.setItem(`${storagePrefix}-${scope}-${name}`, value);
}
function loadFromLocalStorage(scope, name) {
  return localStorage.getItem(`${storagePrefix}-${scope}-${name}`) || void 0;
}
function loadFromSessionStorage(scope, name) {
  return sessionStorage.getItem(`${storagePrefix}-${scope}-${name}`) || void 0;
}
function deleteFromLocalStorage(scope, name) {
  localStorage.removeItem(`${storagePrefix}-${scope}-${name}`);
}
function deleteFromSessionStorage(scope, name) {
  sessionStorage.removeItem(`${storagePrefix}-${scope}-${name}`);
}
function loadAndDeleteFromSessionStorage(scope, name) {
  const id = `${storagePrefix}-${scope}-${name}`;
  const result2 = sessionStorage.getItem(id) || void 0;
  sessionStorage.removeItem(id);
  return result2;
}
function loadAccessTokenFromStorage(hostConfig) {
  if (!hostConfig.clientId) {
    return void 0;
  }
  if (hostConfig.accessTokenStorage === "local") {
    return loadFromLocalStorage(hostConfig.clientId, "access-token");
  }
  if (hostConfig.accessTokenStorage === "session") {
    return loadFromSessionStorage(hostConfig.clientId, "access-token");
  }
  return void 0;
}
async function loadOrAcquireAccessToken(hostConfig, acquireToken) {
  if (!hostConfig.clientId) {
    throw new InvalidHostConfigError('A host config with authType set to "oauth2" has to also provide a clientId');
  }
  const storedToken = hostConfig.clientId ? tokens[hostConfig.clientId] || loadAccessTokenFromStorage(hostConfig) : void 0;
  if (storedToken) {
    return Promise.resolve(storedToken);
  }
  const token = acquireToken();
  tokens[hostConfig.clientId] = token;
  const awaitedToken = await token;
  if (hostConfig.accessTokenStorage === "local" && awaitedToken) {
    saveInLocalStorage(hostConfig.clientId, "access-token", awaitedToken);
  } else if (hostConfig.accessTokenStorage === "session" && awaitedToken) {
    saveInSessionStorage(hostConfig.clientId, "access-token", awaitedToken);
  }
  return token;
}
function clearStoredAccessToken(hostConfig) {
  if (!hostConfig.clientId) {
    throw new InvalidHostConfigError('A host config with authType set to "oauth2" has to also provide a clientId');
  }
  delete tokens[hostConfig.clientId];
  deleteFromLocalStorage(hostConfig.clientId, "access-token");
  deleteFromSessionStorage(hostConfig.clientId, "access-token");
}

// src/auth/internal/default-auth-modules/oauth/callback.ts
function handleOAuthCallback() {
  const urlParams = new URLSearchParams(globalThis.location.search);
  const callbackCode = urlParams.get("code") || void 0;
  const callbackState = urlParams.get("state") || void 0;
  if (urlParams.get("error")) {
    const element = document.createElement("pre");
    element.innerText = `<code>${JSON.stringify({
      error: urlParams.get("error"),
      error_code: urlParams.get("error_code"),
      error_description: urlParams.get("error_description"),
      error_detail: urlParams.get("error_detail"),
      error_uri: urlParams.get("error_uri")
    })}</code>`;
    document.body.prepend(element);
  }
  const clientId = loadAndDeleteFromSessionStorage("", "client-in-progress");
  if (clientId && callbackCode && callbackState) {
    const stateFromLocalStorage = loadAndDeleteFromSessionStorage(clientId, "state");
    const finalRedirectUri = loadAndDeleteFromSessionStorage(clientId, "href");
    if (stateFromLocalStorage && stateFromLocalStorage === callbackState && finalRedirectUri) {
      saveInSessionStorage(clientId, "code", callbackCode);
      if (finalRedirectUri !== globalThis.location.href) {
        globalThis.location.replace(finalRedirectUri);
      }
    }
  }
}

// src/auth/internal/default-auth-modules/oauth/oauth-utils.ts
function generateRandomString(targetLength) {
  const byteArrayLength = Math.ceil(targetLength * 3 / 4);
  const array = new Uint8Array(byteArrayLength);
  globalThis.crypto.getRandomValues(array);
  const base64UrlString = toBase64Url(array);
  return base64UrlString.substring(0, targetLength);
}
function toBase64Url(uint8Array) {
  const hashArray = Array.from(uint8Array);
  const regularBase64 = byteArrayToBase64(hashArray);
  return regularBase64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function byteArrayToBase64(hashArray) {
  let result2 = "";
  if (typeof globalThis.Buffer !== "undefined") {
    result2 = Buffer.from(hashArray).toString("base64");
  } else if (typeof window !== "undefined" && typeof window.btoa === "function") {
    const byteArrayToString = String.fromCharCode.apply(null, hashArray);
    result2 = window.btoa(byteArrayToString);
  } else {
    throw new Error("Environment not supported");
  }
  return result2;
}
async function sha256(message) {
  const msgBuffer = new TextEncoder().encode(message);
  const hashBuffer = await globalThis.crypto.subtle.digest("SHA-256", msgBuffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashBase64 = byteArrayToBase64(hashArray);
  return hashBase64.replaceAll(/\+/g, "-").replaceAll(/\//g, "_").replace(/=+$/, "");
}
function toQueryString(queryParams) {
  const queryParamsKeys = Object.keys(queryParams);
  queryParamsKeys.sort();
  const query = queryParamsKeys.map((k) => `${k}=${queryParams[k]}`).join("&");
  return query;
}
async function startFullPageLoginFlow(hostConfig) {
  const clientId = hostConfig.clientId || "";
  const locationUrl = toValidLocationUrl(hostConfig);
  const verifier = generateRandomString(128);
  const state = generateRandomString(43);
  const codeChallenge = await sha256(verifier);
  const redirectUri = hostConfig.redirectUri || globalThis.location.href;
  const scopes = ["user_default"];
  clearStoredAccessToken(hostConfig);
  saveInSessionStorage(clientId, "state", state);
  saveInSessionStorage(clientId, "verifier", verifier);
  saveInSessionStorage(clientId, "href", globalThis.location.href);
  saveInSessionStorage("", "client-in-progress", clientId);
  const queryParams = {
    response_type: "code",
    client_id: clientId,
    redirect_uri: redirectUri,
    scope: scopes.join(" "),
    state,
    code_challenge: codeChallenge,
    code_challenge_method: "S256"
  };
  const url = `${locationUrl}/oauth/authorize?${toQueryString(queryParams)}`;
  globalThis.location.replace(url);
}
async function exchangeCodeAndVerifierForAccessTokenData(hostConfig, code, verifier, redirectUri) {
  try {
    const result2 = await fetch(`${toValidLocationUrl(hostConfig)}/oauth/token`, {
      method: "POST",
      credentials: "include",
      mode: "cors",
      headers: { "content-type": "application/json" },
      redirect: "follow",
      body: JSON.stringify({
        grant_type: "authorization_code",
        scope: hostConfig.scope || "user_default",
        ...code ? { code } : {},
        ...{ redirect_uri: redirectUri || globalThis.location.href },
        ...verifier ? { code_verifier: verifier } : {},
        client_id: hostConfig.clientId
      })
    });
    const data = await result2.json();
    return {
      accessToken: data.access_token,
      refreshToken: data.refresh_token
    };
  } catch (err) {
    console.error(err);
    return new Promise(() => {
    });
  }
}
async function getOAuthAccessTokenInternal(hostConfig) {
  const { clientId } = hostConfig;
  if (!clientId) {
    throw new InvalidHostConfigError('A host config with authType set to "oauth2" has to also provide a clientId');
  }
  const accessToken = await loadOrAcquireAccessToken(hostConfig, async () => {
    const code = loadAndDeleteFromSessionStorage(clientId, "code");
    const verifier = loadAndDeleteFromSessionStorage(clientId, "verifier");
    if (code && verifier) {
      const tokensResponse = await exchangeCodeAndVerifierForAccessTokenData(
        hostConfig,
        code,
        verifier,
        hostConfig.redirectUri
      );
      if (tokensResponse) {
        return tokensResponse.accessToken;
      }
    }
    return void 0;
  });
  if (accessToken) {
    return accessToken;
  }
  if (hostConfig.authRedirectUserConfirmation) {
    await hostConfig.authRedirectUserConfirmation();
  }
  startFullPageLoginFlow(hostConfig);
  return new Promise(() => {
  });
}
var lastOauthAccessTokenCall = Promise.resolve("");
async function getOAuthAccessToken(hostConfig) {
  lastOauthAccessTokenCall = lastOauthAccessTokenCall.then(async () => getOAuthAccessTokenInternal(hostConfig));
  return lastOauthAccessTokenCall;
}

// src/auth/internal/default-auth-modules/oauth/temporary-token.ts
async function exchangeAccessTokenForTemporaryToken(hostConfig, accessToken, purpose) {
  const result2 = await fetch(`${toValidLocationUrl(hostConfig)}/oauth/token`, {
    method: "POST",
    credentials: "include",
    mode: "cors",
    headers: { "content-type": "application/json" },
    redirect: "follow",
    body: JSON.stringify({
      subject_token: accessToken,
      subject_token_type: "urn:ietf:params:oauth:token-type:access_token",
      grant_type: "urn:ietf:params:oauth:grant-type:token-exchange",
      purpose,
      redirect_uri: globalThis.location?.href,
      client_id: hostConfig.clientId
    })
  });
  if (result2.status === 401) {
    if (hostConfig.authRedirectUserConfirmation) {
      await hostConfig.authRedirectUserConfirmation();
    }
    startFullPageLoginFlow(hostConfig);
    return new Promise(() => {
    });
  }
  const data = await result2.json();
  return data.access_token;
}

// src/auth/internal/default-auth-modules/oauth.ts
if (typeof window !== "undefined") {
  handleOAuthCallback();
}
async function getRestCallAuthParams5({
  hostConfig
}) {
  return {
    headers: {
      Authorization: `Bearer ${await getOAuthAccessToken(hostConfig)}`
    },
    queryParams: {},
    credentials: "omit"
  };
}
async function getWebSocketAuthParams5({
  hostConfig
}) {
  const accessToken = await getOAuthAccessToken(hostConfig);
  const websocketAccessToken = await exchangeAccessTokenForTemporaryToken(hostConfig, accessToken, "websocket");
  return {
    queryParams: {
      accessToken: websocketAccessToken
    }
  };
}
async function getWebResourceAuthParams2({
  hostConfig
}) {
  const accessToken = await getOAuthAccessToken(hostConfig);
  const webResourceAccessToken = await exchangeAccessTokenForTemporaryToken(hostConfig, accessToken, "webresource");
  return {
    queryParams: {
      accessToken: webResourceAccessToken
    }
  };
}
async function handleAuthenticationError5({
  hostConfig
}) {
  if (hostConfig.authRedirectUserConfirmation) {
    await hostConfig.authRedirectUserConfirmation();
  }
  startFullPageLoginFlow(hostConfig);
  return {
    preventDefault: true
  };
}
var oauth_default = {
  getRestCallAuthParams: getRestCallAuthParams5,
  getWebSocketAuthParams: getWebSocketAuthParams5,
  getWebResourceAuthParams: getWebResourceAuthParams2,
  handleAuthenticationError: handleAuthenticationError5,
  validateHostConfig: (hostConfig) => internalValidateHostConfig(hostConfig, {
    requiredProps: ["clientId"],
    optionalProps: ["redirectUri", "accessTokenStorage"]
  })
};

// src/auth/internal/default-auth-modules/windows-cookie/xrf-keys.ts
var xrfKeys = {};
function createXrfKey() {
  let result2 = "";
  for (let i = 0; i < 16; i += 1) {
    const j = Math.floor(Math.random() * 62);
    if (j < 10) {
      result2 += j;
    } else if (j > 9 && j < 36) {
      result2 += String.fromCharCode(j + 55);
    } else {
      result2 += String.fromCharCode(j + 61);
    }
  }
  return result2;
}
function getXrfKey(hostConfig) {
  const locationUrl = toValidLocationUrl(hostConfig);
  xrfKeys[locationUrl] = xrfKeys[locationUrl] || createXrfKey();
  return xrfKeys[locationUrl];
}

// src/auth/internal/default-auth-modules/windows-cookie.ts
function getRestCallAuthParams6({
  hostConfig
}) {
  return Promise.resolve({
    headers: {
      "X-Qlik-XrfKey": getXrfKey(hostConfig)
    },
    queryParams: {
      xrfkey: getXrfKey(hostConfig)
    },
    credentials: getCredentialsForCookieAuth(hostConfig)
  });
}
function getWebSocketAuthParams6({
  hostConfig
}) {
  return Promise.resolve({
    queryParams: {
      xrfkey: getXrfKey(hostConfig)
    }
  });
}
async function handleAuthenticationError6({
  hostConfig
}) {
  if (hostConfig.loginUri) {
    if (hostConfig.authRedirectUserConfirmation) {
      await hostConfig.authRedirectUserConfirmation();
    }
    globalThis.location.replace(
      hostConfig.loginUri.replace("{location}", encodeURIComponent(globalThis.location.href))
    );
    return {
      preventDefault: true
    };
  }
  return {
    // Do nothing, just let the error be thrown to calling code
  };
}
var windows_cookie_default = {
  getRestCallAuthParams: getRestCallAuthParams6,
  getWebSocketAuthParams: getWebSocketAuthParams6,
  handleAuthenticationError: handleAuthenticationError6,
  validateHostConfig: (hostConfig) => internalValidateHostConfig(hostConfig, {
    requiredProps: [],
    optionalProps: ["loginUri", "crossSiteCookies"]
  })
};

// src/auth/auth.ts
globalThis.loggingOut = false;
var authModulesRegistered = false;
function registerDefaultAuthModules() {
  if (!authModulesRegistered) {
    registerAuthModule("apikey", apikey_default);
    registerAuthModule("cookie", cookie_default);
    registerAuthModule("none", none_default);
    registerAuthModule("oauth2", oauth_default);
    registerAuthModule("windowscookie", windows_cookie_default);
    authModulesRegistered = true;
  }
}
registerDefaultAuthModules();
var auth = {
  logout,
  registerAuthModule,
  setDefaultHostConfig: setDefaultHostConfig2,
  getRestCallAuthParams,
  getWebSocketAuthParams,
  getWebResourceAuthParams,
  handleAuthenticationError,
  toValidLocationUrl,
  toValidEnigmaLocationUrl,
  toValidWebsocketLocationUrl,
  isWindows,
  isHostCrossOrigin
};
var auth_default = auth;

// src/invoke-fetch/internal/invoke-fetch-helpers.ts
function encodeQueryParams(query) {
  if (query) {
    return Object.entries(query).map((kv) => {
      const [, value] = kv;
      if (value === void 0) {
        return void 0;
      }
      return kv.map(
        (val) => (
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          encodeURIComponent(val)
        )
      ).join("=");
    }).filter(Boolean).join("&");
  }
  return "";
}
function applyPathVariables(pathTemplate, pathVariables) {
  let result2 = pathTemplate;
  if (pathVariables) {
    Object.keys(pathVariables).forEach((key) => {
      result2 = result2.replace(`{${key}}`, pathVariables[key]);
    });
  }
  return result2;
}
function toCacheKey(url, query, headers) {
  let cacheKey = url;
  if (query !== "") {
    cacheKey = cacheKey.concat(`?${query}`);
  }
  if (headers) {
    cacheKey = cacheKey.concat(`+headers=${JSON.stringify(headers)}`);
  }
  return cacheKey;
}
function toCompleteUrl(url, query) {
  if (query !== "") {
    return `${url}?${query}`;
  }
  return url;
}
function shouldUseCachedResult(options, cacheEntry, defaultMaxCacheTime) {
  if (!cacheEntry || typeof cacheEntry.value === void 0) {
    return false;
  }
  if (options?.noCache) {
    return false;
  }
  if (options?.useCacheIfAfter) {
    return options.useCacheIfAfter.getTime() <= cacheEntry.lastPulled;
  }
  const age = Date.now() - cacheEntry.lastPulled;
  if (options?.maxCacheAge) {
    return age <= options?.maxCacheAge;
  }
  return age < defaultMaxCacheTime;
}
var shouldPopulateCache = (method) => method === "get" || method === "GET";
function clone(value) {
  return JSON.parse(JSON.stringify(value));
}
function isModifyingVerb2(verb) {
  return !(verb === "get" || verb === "GET");
}
function cacheKeyToUrl(cachedUrl) {
  const queryIdx = cachedUrl.indexOf("?");
  if (queryIdx >= 0) {
    return cachedUrl.substring(0, queryIdx);
  }
  const headersIdx = cachedUrl.indexOf("+headers=");
  if (headersIdx >= 0) {
    return cachedUrl.substring(0, headersIdx);
  }
  return cachedUrl;
}
function clearRelatedCacheEntries(cache2, cacheKey) {
  const modifyingUrl = cacheKeyToUrl(cacheKey);
  for (const existingCacheKey in cache2) {
    const cleanUrl = cacheKeyToUrl(existingCacheKey);
    if (
      // Either up or down the path...
      modifyingUrl.startsWith(cleanUrl) || cleanUrl.startsWith(modifyingUrl)
    ) {
      delete cache2[existingCacheKey];
    }
  }
}
function cloneResultPromise(value) {
  return value.then((resp) => {
    const result2 = {
      data: clone(resp.data),
      headers: resp.headers,
      status: resp.status
    };
    if (resp.next) {
      result2.next = resp.next;
    }
    if (resp.prev) {
      result2.prev = resp.prev;
    }
    return result2;
  });
}
function clearCacheOnError(cacheEntry, cacheKey, value) {
  return value.catch((error) => {
    delete cacheEntry[cacheKey];
    return Promise.reject(error);
  });
}

// src/invoke-fetch/internal/invoke-fetch-methods.ts
var defaultCacheTime = 1e3 * 60 * 10;
var cache = {};
globalThis.__API_CACHE__DO_NOT_USE_OR_YOU_WILL_BE_FIRED = cache;
function clearApiCacheInternal(api) {
  cache[api] = {};
}
function getErrorMessage(error) {
  if (error instanceof Error) {
    if (error.cause) {
      if (error.message) {
        return `${error.message} - ${getErrorMessage(error.cause)}`;
      }
      return getErrorMessage(error.cause);
    }
    return error.message;
  }
  return String(error);
}
async function fetchAndTransformExceptions(input, init) {
  try {
    return await fetch(input, init);
  } catch (e) {
    return Promise.reject(new InvokeFetchError(getErrorMessage(e), 0, new Headers(), {}));
  }
}
async function performActualHttpFetch(method, completeUrl, body, options, interceptors, authHeaders, credentials) {
  const headers = {
    "Content-Type": "application/json",
    ...authHeaders,
    ...options?.headers
  };
  const isCrossOrigin = isHostCrossOrigin(options?.hostConfig);
  let request = {
    method,
    credentials,
    mode: isCrossOrigin ? "cors" : "same-origin",
    headers,
    redirect: await isWindows(options?.hostConfig) ? "manual" : "follow",
    body: body ? JSON.stringify(body) : null
    // body data type must match "Content-Type" header
  };
  let fetchTimeoutId;
  if (options?.timeoutMs && options.timeoutMs > 0) {
    const controller = new AbortController();
    fetchTimeoutId = setTimeout(() => {
      controller.abort();
    }, options.timeoutMs);
    request.signal = controller.signal;
  }
  if (interceptors?.request.hasInterceptors()) {
    request = await interceptors.request.apply(completeUrl, request);
  }
  const fetchResponse = await fetchAndTransformExceptions(completeUrl, request);
  if (fetchTimeoutId) {
    clearTimeout(fetchTimeoutId);
  }
  let invokeFetchResponse = await parseFetchResponse2(fetchResponse, completeUrl);
  if (interceptors?.response.hasInterceptors()) {
    invokeFetchResponse = await interceptors.response.apply(invokeFetchResponse);
  }
  return invokeFetchResponse;
}
async function getInvokeFetchUrlParams({
  method,
  pathTemplate,
  pathVariables,
  query,
  options
}) {
  const locationUrl = toValidLocationUrl(options?.hostConfig);
  const {
    headers: authHeaders,
    queryParams: authQueryParams,
    credentials
  } = await getRestCallAuthParams({
    hostConfig: options?.hostConfig,
    method
  });
  const url = locationUrl + applyPathVariables(pathTemplate, pathVariables);
  const queryString = encodeQueryParams({ ...query, ...authQueryParams });
  const completeUrl = toCompleteUrl(url, queryString);
  const cacheKey = toCacheKey(url, queryString, options?.headers);
  return { completeUrl, cacheKey, authHeaders, credentials };
}
function invokeFetchWithUrl(api, props, interceptors) {
  return invokeFetchWithUrlAndRetry(
    api,
    props,
    async () => {
      const { cacheKey, authHeaders, credentials } = await getInvokeFetchUrlParams(props);
      return invokeFetchWithUrlAndRetry(
        api,
        { ...props, cacheKey, authHeaders, credentials },
        void 0,
        // only retry once
        interceptors
      );
    },
    interceptors
  );
}
function invokeFetchWithUrlAndRetry(api, { method, completeUrl, cacheKey, body, options, authHeaders, credentials }, performRetry, interceptors) {
  if (!cache[api]) {
    cache[api] = {};
  }
  const cacheEntry = isModifyingVerb2(method) ? void 0 : cache[api][cacheKey];
  if (isModifyingVerb2(method)) {
    clearRelatedCacheEntries(cache[api], cacheKey);
  }
  if (cacheEntry && shouldUseCachedResult(options, cacheEntry, defaultCacheTime)) {
    cacheEntry.lastHit = /* @__PURE__ */ new Date();
    cacheEntry.hitCount += 1;
    cacheEntry.accessedPaths.add(globalThis.location ? globalThis.location.pathname : "node");
    return cloneResultPromise(cacheEntry.value);
  }
  const resultPromiseFromBackend = performActualHttpFetch(
    method,
    completeUrl,
    body,
    options,
    interceptors,
    authHeaders,
    credentials
  );
  const resultAfterAuthenticationCheck = interceptAuthenticationErrors(
    options?.hostConfig,
    resultPromiseFromBackend,
    performRetry
  );
  const resultPromiseAfterPagingAddon = addPagingFunctions(
    api,
    resultAfterAuthenticationCheck,
    method,
    body,
    options,
    interceptors,
    authHeaders,
    credentials
  );
  const resultPromiseAfterCacheClearing = clearCacheOnError(cache[api], cacheKey, resultPromiseAfterPagingAddon);
  if (shouldPopulateCache(method)) {
    if (Object.hasOwn && !Object.hasOwn(cache, api) || api === "__proto__") {
      throw new Error(`Forbidden api name: ${api}`);
    }
    cache[api][cacheKey] = {
      lastPulled: Date.now(),
      value: resultPromiseAfterCacheClearing,
      lastHit: null,
      hitCount: 0,
      accessedPaths: /* @__PURE__ */ new Set()
    };
  }
  return cloneResultPromise(resultPromiseAfterCacheClearing);
}
function addPagingFunctions(api, value, method, body, options, interceptors, authHeaders, credentials) {
  return value.then((resp) => {
    const dataWithPotentialLinks = resp.data;
    const prevUrl = dataWithPotentialLinks.links?.prev?.href;
    const nextUrl = dataWithPotentialLinks.links?.next?.href;
    if (prevUrl) {
      resp.prev = (prevOptions) => invokeFetchWithUrl(
        api,
        {
          method,
          completeUrl: prevUrl,
          body,
          options: prevOptions || options,
          cacheKey: toCacheKey(prevUrl, "", options?.headers),
          authHeaders,
          credentials
        },
        interceptors
      );
    }
    if (nextUrl) {
      resp.next = (nextOptions) => invokeFetchWithUrl(
        api,
        {
          method,
          completeUrl: nextUrl,
          body,
          options: nextOptions || options,
          cacheKey: toCacheKey(nextUrl, "", options?.headers),
          authHeaders,
          credentials
        },
        interceptors
      );
    }
    return resp;
  });
}
function neverResolvingPromise() {
  return new Promise(() => {
  });
}
async function interceptAuthenticationErrors(hostConfig, resultPromise, performRetry) {
  try {
    return await resultPromise;
  } catch (error) {
    const err = error;
    if (err.status === 401 || err.status === 403 || (err.status === 301 || err.status === 302) && await isWindows(hostConfig)) {
      if (globalThis.loggingOut) {
        return await neverResolvingPromise();
      }
      const { retry, preventDefault } = await handleAuthenticationError({
        hostConfig,
        status: err.status,
        headers: err.headers,
        errorBody: err.data,
        canRetry: !!performRetry
      });
      if (retry && performRetry) {
        return await performRetry();
      }
      if (preventDefault) {
        return neverResolvingPromise();
      }
    }
    throw error;
  }
}
async function parseFetchResponse2(fetchResponse, url) {
  let resultData;
  try {
    resultData = await fetchResponse.text();
    resultData = JSON.parse(resultData);
  } catch {
  }
  const { status, statusText, headers } = fetchResponse;
  const errorMsg = `request to '${url}' failed with status ${status} ${statusText}.`;
  if (status >= 300) {
    throw new InvokeFetchError(errorMsg, status, headers, resultData);
  }
  if (status === 0) {
    throw new InvokeFetchError(errorMsg, 302, headers, resultData);
  }
  const invokeFetchResponse = {
    status,
    headers,
    data: resultData
  };
  return invokeFetchResponse;
}

// src/invoke-fetch/invoke-fetch-error.ts
var InvokeFetchError = class extends Error {
  status;
  headers;
  data;
  constructor(errorMessage, status, headers, data) {
    super(errorMessage);
    this.status = status;
    this.headers = headers;
    this.data = data;
    this.stack = cleanStack(this.stack);
  }
};
var regex = /^.+\/qmfe-api(?:\.js)?:(\d+)(?::\d+)?$/gim;
var isFromQmfeApi = (line) => {
  const matches = line.match(regex);
  return Boolean(matches && matches.length > 0);
};
function cleanStack(stack) {
  if (!stack) {
    return stack;
  }
  const newStack = [];
  const lines = stack.split("\n");
  lines.reverse();
  for (const line of lines) {
    if (isFromQmfeApi(line)) {
      break;
    }
    newStack.unshift(line);
  }
  return newStack.join("\n");
}

// src/invoke-fetch/invoke-fetch-functions.ts
async function invokeFetch(api, props, interceptors) {
  checkForCrossDomainRequest(props.options?.hostConfig);
  const { completeUrl, cacheKey, authHeaders, credentials } = await getInvokeFetchUrlParams(props);
  return invokeFetchWithUrl(
    api,
    { ...props, method: props.method.toUpperCase(), completeUrl, cacheKey, authHeaders, credentials },
    interceptors
  );
}
function clearApiCache(api) {
  clearApiCacheInternal(api);
}
async function parseFetchResponse(fetchResponse, url) {
  let resultData;
  try {
    resultData = await fetchResponse.text();
    resultData = JSON.parse(resultData);
  } catch {
  }
  const { status, statusText, headers } = fetchResponse;
  const errorMsg = `request to '${url}' failed with status ${status} ${statusText}.`;
  if (status >= 300) {
    throw new InvokeFetchError(errorMsg, status, headers, resultData);
  }
  if (status === 0) {
    throw new InvokeFetchError(errorMsg, 302, headers, resultData);
  }
  const invokeFetchResponse = {
    status,
    headers,
    data: resultData
  };
  return invokeFetchResponse;
}

// src/invoke-fetch/invoke-fetch.ts
var invokeFetchExp = {
  invokeFetch,
  clearApiCache,
  parseFetchResponse
};
var invoke_fetch_default = invokeFetchExp;

export {
  getPlatform,
  InvalidHostConfigError,
  UnexpectedAuthTypeError,
  InvalidAuthTypeError,
  isHostCrossOrigin,
  isWindows,
  toValidLocationUrl,
  toValidEnigmaLocationUrl,
  toValidWebsocketLocationUrl,
  getWebSocketAuthParams,
  getWebResourceAuthParams,
  handleAuthenticationError,
  getRestCallAuthParams,
  registerAuthModule2 as registerAuthModule,
  setDefaultHostConfig2 as setDefaultHostConfig,
  checkForCrossDomainRequest,
  logout,
  InvokeFetchError,
  invokeFetch,
  clearApiCache,
  parseFetchResponse,
  invoke_fetch_default,
  auth_default
};
